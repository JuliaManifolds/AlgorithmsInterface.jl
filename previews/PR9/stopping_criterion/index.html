<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stopping criteria · AlgorithmsInterface.jl</title><meta name="title" content="Stopping criteria · AlgorithmsInterface.jl"/><meta property="og:title" content="Stopping criteria · AlgorithmsInterface.jl"/><meta property="twitter:title" content="Stopping criteria · AlgorithmsInterface.jl"/><meta name="description" content="Documentation for AlgorithmsInterface.jl."/><meta property="og:description" content="Documentation for AlgorithmsInterface.jl."/><meta property="twitter:description" content="Documentation for AlgorithmsInterface.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="AlgorithmsInterface.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">AlgorithmsInterface.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../interface/">Interface</a></li><li class="is-active"><a class="tocitem" href>Stopping criteria</a><ul class="internal"><li><a class="tocitem" href="#Why-separate-stopping-logic?"><span>Why separate stopping logic?</span></a></li><li><a class="tocitem" href="#Built-in-criteria:-Heron&#39;s-method"><span>Built-in criteria: Heron&#39;s method</span></a></li><li><a class="tocitem" href="#Implementing-a-new-criterion"><span>Implementing a new criterion</span></a></li><li><a class="tocitem" href="#Reference-API"><span>Reference API</span></a></li></ul></li><li><a class="tocitem" href="../logging/">Logging</a></li><li><a class="tocitem" href="../notation/">Notation</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Stopping criteria</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Stopping criteria</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/main/docs/src/stopping_criterion.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="sec_stopping"><a class="docs-heading-anchor" href="#sec_stopping">Stopping criteria</a><a id="sec_stopping-1"></a><a class="docs-heading-anchor-permalink" href="#sec_stopping" title="Permalink"></a></h1><p>Continuing the square‑root story from the <a href="../interface/#sec_interface">Interface</a> page, we now decide <strong>when</strong> the iteration should halt. A stopping criterion encapsulates halting logic separately from the algorithm update rule.</p><h2 id="Why-separate-stopping-logic?"><a class="docs-heading-anchor" href="#Why-separate-stopping-logic?">Why separate stopping logic?</a><a id="Why-separate-stopping-logic?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-separate-stopping-logic?" title="Permalink"></a></h2><p>Decoupling halting from stepping lets us:</p><ul><li>Reuse generic stopping (iteration caps, time limits) across algorithms.</li><li>Compose multiple conditions (stop after 1 second OR 100 iterations, etc.).</li><li>Query convergence indication vs. mere forced termination.</li><li>Store structured reasons and state (e.g. at which iteration a threshold was met).</li></ul><h2 id="Built-in-criteria:-Heron&#39;s-method"><a class="docs-heading-anchor" href="#Built-in-criteria:-Heron&#39;s-method">Built-in criteria: Heron&#39;s method</a><a id="Built-in-criteria:-Heron&#39;s-method-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-criteria:-Heron&#39;s-method" title="Permalink"></a></h2><p>The package ships several concrete <a href="../interface/#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a>s:</p><ul><li><a href="#AlgorithmsInterface.StopAfterIteration"><code>StopAfterIteration</code></a>: stop after a maximum number of iterations.</li><li><a href="#AlgorithmsInterface.StopAfter"><code>StopAfter</code></a>: stop after a wall‑clock time <code>Period</code> (e.g. <code>Second(2)</code>, <code>Minute(1)</code>).</li><li>Combinations <a href="#AlgorithmsInterface.StopWhenAll"><code>StopWhenAll</code></a> (logical AND) and <a href="#AlgorithmsInterface.StopWhenAny"><code>StopWhenAny</code></a> (logical OR) built via <code>&amp;</code> and <code>|</code> operators.</li></ul><p>Each criterion has an associated <a href="../interface/#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> storing dynamic data (iteration when met, elapsed time, etc.).</p><p>Recall our <a href="../interface/#sec_heron">example implementation</a> for Heron&#39;s method, where we we added a <code>stopping_criterion</code> to the <code>Algorithm</code>, as well as a <code>stopping_criterion_state</code> to the <code>State</code>.</p><pre><code class="language-julia hljs">using AlgorithmsInterface

struct SqrtProblem &lt;: Problem
    S::Float64                # number whose square root we seek
end

struct HeronAlgorithm &lt;: Algorithm
    stopping_criterion        # any StoppingCriterion
end

mutable struct HeronState &lt;: State
    iterate::Float64          # current iterate
    iteration::Int            # current iteration count
    stopping_criterion_state  # any StoppingCriterionState
end</code></pre><p>Here, we delve a bit deeper into the core components of what made our algorithm stop, even though we had to add very little additional functionality.</p><h3 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h3><p>The first core component to enable working with stopping criteria is to extend the initialization step to include initializing a <a href="../interface/#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> as well. Since some of these may require <em>stateful</em> implementations, we also keep a <code>stopping_criterion_state</code> that captures this, and thus needs to be initialized. By default, the initialization happens automatically and the only thing that is left for us to do is to attach this <code>stopping_criterion_state</code> to the <code>state</code> in the <a href="../interface/#AlgorithmsInterface.initialize_state-Tuple{Problem, Algorithm}"><code>initialize_state</code></a> function, as we already saw before:</p><pre><code class="language-julia hljs">function AlgorithmsInterface.initialize_state(
        problem::SqrtProblem, algorithm::HeronAlgorithm,
        stopping_criterion_state::StoppingCriterionState;
        kwargs...
    )
    x0 = rand()
    iteration = 0
    return HeronState(x0, 0, stopping_criterion_state)
end

function AlgorithmsInterface.initialize_state!(
        problem::SqrtProblem, algorithm::HeronAlgorithm, state::HeronState;
        kwargs...
    )
    state.iteration = 0
    return state
end</code></pre><p>Note that we do not need to handle any stopping criteria in the <a href="../interface/#AlgorithmsInterface.initialize_state!-Tuple{Problem, Algorithm, State}"><code>initialize_state!</code></a> function, as a separate call to <a href="../interface/#AlgorithmsInterface.initialize_stopping_state!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>AlgorithmsInterface.initialize_stopping_state!</code></a> is made independently.</p><h3 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h3><p>During the iteration procedure, as set out by our design principles, we do not have to modify any of the code, and the stopping criteria do not show up:</p><pre><code class="language-julia hljs">function AlgorithmsInterface.step!(problem::SqrtProblem, algorithm::HeronAlgorithm, state::HeronState)
    S = problem.S
    x = state.iterate
    state.iterate = 0.5 * (x + S / x)
    return state
end</code></pre><p>What is really going on is that behind the scenes, the loop of the iterative solver expands to code that is equivalent to:</p><pre><code class="language-julia hljs">while !is_finished!(problem, algorithm,  state)
    increment!(state)
    step!(problem, algorithm, state)
end</code></pre><p>In other words, all of the logic is handled by the <a href="../interface/#AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>is_finished!</code></a> function. The generic stopping criteria provided by this package have default implementations for this function that work out-of-the-box. This is partially because we used conventional names for the fields in the structs. There, <code>Algorithm</code> assumes the existence of <code>stopping_criterion</code>, while <code>State</code> assumes <code>iterate</code> and <code>iteration</code> and <code>stopping_criterion_state</code> to exist.</p><h3 id="Running-the-algorithm"><a class="docs-heading-anchor" href="#Running-the-algorithm">Running the algorithm</a><a id="Running-the-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-algorithm" title="Permalink"></a></h3><p>We can again combine everything into a single function, but now make the stopping criterion accessible:</p><pre><code class="language-julia hljs">function heron_sqrt(x; stopping_criterion)
    prob = SqrtProblem(x)
    alg  = HeronAlgorithm(stopping_criterion)
    state = solve(prob, alg)  # allocates &amp; runs
    return state.iterate, state.iteration
end

heron_sqrt(2; stopping_criterion = StopAfterIteration(10))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.414213562373095, 10)</code></pre><p>With this function, we are now ready to explore different ways of telling the algorithm to stop. For example, using the basic criteria provided by this package, we can alternatively do:</p><pre><code class="language-julia hljs">using Dates
criterion = StopAfter(Millisecond(50))
heron_sqrt(2; stopping_criterion = criterion)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.414213562373095, 161982)</code></pre><p>We can tighten the condition by combining criteria. Suppose we want to stop after either 25 iterations or 50 milliseconds, whichever comes first:</p><pre><code class="language-julia hljs">criterion = StopAfterIteration(25) | StopAfter(Millisecond(50))  # logical OR
heron_sqrt(2; stopping_criterion = criterion)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.414213562373095, 25)</code></pre><p>Conversely, to demand both a minimum iteration quality condition <strong>and</strong> a cap, use <code>&amp;</code> (logical AND).</p><pre><code class="language-julia hljs">criterion = StopAfterIteration(25) &amp; StopAfter(Millisecond(50))  # logical AND
heron_sqrt(2; stopping_criterion = criterion)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.414213562373095, 149011)</code></pre><h2 id="Implementing-a-new-criterion"><a class="docs-heading-anchor" href="#Implementing-a-new-criterion">Implementing a new criterion</a><a id="Implementing-a-new-criterion-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-a-new-criterion" title="Permalink"></a></h2><p>It is of course possible that we are not satisfied by the stopping criteria that are provided by default. For example, we might check for convergence by squaring our current <code>iterate</code> and seeing if it equals the input value. In order to do so, we need to define our own struct and implement the required interface.</p><pre><code class="language-julia hljs">struct StopWhenSquared &lt;: StoppingCriterion
    tol::Float64    # when do we consider things to be converged
end</code></pre><h3 id="Checking-for-convergence"><a class="docs-heading-anchor" href="#Checking-for-convergence">Checking for convergence</a><a id="Checking-for-convergence-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-for-convergence" title="Permalink"></a></h3><p>Then, we need to implement the logic that checks whether an algorithm has finished, which is achieved through <a href="../interface/#AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>is_finished</code></a> and <a href="../interface/#AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>is_finished!</code></a>.</p><pre><code class="language-julia hljs">using AlgorithmsInterface: DefaultStoppingCriterionState

function AlgorithmsInterface.is_finished(
        problem::SqrtProblem, ::Algorithm, state::State,
        stopping_criterion::StopWhenSquared, ::DefaultStoppingCriterionState
    )
    return state.iteration &gt; 0 &amp;&amp; isapprox(state.iterate^2, problem.S; atol = stopping_criterion.tol)
end</code></pre><p>Note that we automatically obtain a <code>DefaultStoppingCriterionState</code> as the final argument, in which we have to store the iteration at which convergence is reached. As this is a mutating operation that alters the <code>stopping_criterion_state</code>, we ensure that it is called exactly once per iteration, while the non-mutating version is simply used to inspect the current status.</p><pre><code class="language-julia hljs">function AlgorithmsInterface.is_finished!(
        problem::SqrtProblem, ::Algorithm, state::State,
        stopping_criterion::StopWhenSquared, stopping_criterion_state::DefaultStoppingCriterionState
    )
    if state.iteration &gt; 0 &amp;&amp; isapprox(state.iterate^2, problem.S; atol = criterion.tol)
        stopping_criterion_state.at_iteration = state.iteration
        return true
    else
        return false
    end
end</code></pre><h3 id="Reason-and-convergence-reporting"><a class="docs-heading-anchor" href="#Reason-and-convergence-reporting">Reason and convergence reporting</a><a id="Reason-and-convergence-reporting-1"></a><a class="docs-heading-anchor-permalink" href="#Reason-and-convergence-reporting" title="Permalink"></a></h3><p>Finally, we need to implement <a href="../interface/#AlgorithmsInterface.get_reason-Tuple{StoppingCriterion, StoppingCriterionState}"><code>get_reason</code></a> and <a href="../interface/#AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion, StoppingCriterionState}"><code>indicates_convergence</code></a>. These helper functions are required to interact with the <a href="../logging/#sec_logging">logging system</a>, to distinguish between states that are considered ongoing, stopped and converged, or stopped without convergence.</p><pre><code class="language-julia hljs">function AlgorithmsInterface.get_reason(stopping_criterion::StopWhenSquared, stopping_criterion_state::DefaultStoppingCriterionState)
    stopping_criterion_state.at_iteration &gt;= 0 || return nothing
    return &quot;The algorithm reached a square root after $(stopping_criterion_state.at_iteration) iterations up to a tolerance of $(stopping_criterion.tol).&quot;
end

AlgorithmsInterface.indicates_convergence(::StopWhenSquared, ::DefaultStoppingCriterionState) = true</code></pre><h3 id="Convergence-in-action"><a class="docs-heading-anchor" href="#Convergence-in-action">Convergence in action</a><a id="Convergence-in-action-1"></a><a class="docs-heading-anchor-permalink" href="#Convergence-in-action" title="Permalink"></a></h3><p>Then we are finally ready to test out our new stopping criteria.</p><pre><code class="language-julia hljs">criterion = StopWhenSquared(1e-8)
heron_sqrt(16.0; stopping_criterion = criterion)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(4.000000000000013, 10)</code></pre><h3 id="Initialization-2"><a class="docs-heading-anchor" href="#Initialization-2">Initialization</a><a class="docs-heading-anchor-permalink" href="#Initialization-2" title="Permalink"></a></h3><p>Now suppose we want to stop when successive iterates change by less than <code>ϵ</code>. This can be achieved by introducing a new stopping criterion again, but now we have to retain the previous <code>iterate</code> in order to have something to compare against. Similar to the algorithm <code>State</code>, we split up the data into a <em>static</em> part, the <a href="../interface/#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a>, and a <em>dynamic</em> part, the <a href="../interface/#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a>.</p><pre><code class="language-julia hljs">struct StopWhenStable &lt;: StoppingCriterion
    tol::Float64    # when do we consider things converged
end

mutable struct StopWhenStableState &lt;: StoppingCriterionState
    previous_iterate::Float64       # previous value to compare to
    at_iteration::Int               # iteration at which stability was reached
    delta::Float64                  # difference between the values
end</code></pre><p>Note that our mutable state holds both the <code>previous_iterate</code>, which we need to compare to, as well as the iteration at which the condition was satisfied. This is not strictly necessary, but can be convenient to have a persistent indication that convergence was reached.</p><p>In order to support these <em>stateful</em> criteria, again an initialization phase is needed. The relevant functions are now:</p><ul><li><a href="../interface/#AlgorithmsInterface.initialize_stopping_state-Tuple{Problem, Algorithm, StoppingCriterion}"><code>AlgorithmsInterface.initialize_stopping_state</code></a></li><li><a href="../interface/#AlgorithmsInterface.initialize_stopping_state!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>AlgorithmsInterface.initialize_stopping_state!</code></a></li></ul><p>This could be implemented as follows:</p><pre><code class="language-julia hljs">function AlgorithmsInterface.initialize_stopping_state(
        ::Problem, ::Algorithm,
        stopping_criterion::StopWhenStable;
        kwargs...
    )
    return StopWhenStableState(NaN, -1, NaN)
end

function AlgorithmsInterface.initialize_stopping_state!(
        ::Problem, ::Algorithm, ::State,
        stopping_criterion::StopWhenStable,
        stopping_criterion_state::StopWhenStableState;
        kwargs...
    )
    stopping_criterion_state.previous_iterate = NaN
    stopping_criterion_state.at_iteration = -1
    stopping_criterion_state.delta = NaN
    return stopping_criterion_state
end</code></pre><div class="admonition is-info" id="Note-bff87f28a9064cd4"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-bff87f28a9064cd4" title="Permalink"></a></header><div class="admonition-body"><p>While for this simple case this does not matter, note that there is a subtle detail associated to the initialization order of the <code>State</code> and <code>StoppingCriterionState</code> respectively. For the first initialization, <a href="../interface/#AlgorithmsInterface.initialize_stopping_state-Tuple{Problem, Algorithm, StoppingCriterion}"><code>AlgorithmsInterface.initialize_stopping_state</code></a> is called <em>before</em> <a href="../interface/#AlgorithmsInterface.initialize_state-Tuple{Problem, Algorithm}"><code>initialize_state</code></a>. This is required since the <code>State</code> encapsulates the <code>StoppingCriterionState</code>. On the other hand, during the solver, the <a href="../interface/#AlgorithmsInterface.initialize_stopping_state!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>AlgorithmsInterface.initialize_stopping_state!</code></a> is called <em>before</em> <a href="../interface/#AlgorithmsInterface.initialize_state-Tuple{Problem, Algorithm}"><code>initialize_state</code></a>. This can be important for example to ensure that the initialization time of the state is taken into account for the stopping criteria.</p></div></div><p>The remainder of the implementation follows straightforwardly, where we again take care to only mutate the <code>stopping_criterion_state</code> in the mutating <code>is_finished!</code> implementation.</p><pre><code class="language-julia hljs">function AlgorithmsInterface.is_finished!(
        ::Problem, ::Algorithm, state::State, c::StopWhenStable, st::StopWhenStableState
    )

	k = state.iteration
	if k == 0
		st.previous_iterate = state.iterate
		st.at_iteration = -1
		return false
	end

	st.delta = abs(state.iterate - st.previous_iterate)
	st.previous_iterate = state.iterate
	if st.delta &lt; c.tol
		st.at_iteration = k
		return true
	end
	return false
end

function AlgorithmsInterface.is_finished(
        ::Problem, ::Algorithm, state::State, c::StopWhenStable, st::StopWhenStableState
    )
	k = state.iteration
	k == 0 &amp;&amp; return false

	Δ = abs(state.iterate - st.previous_iterate)
	return Δ &lt; c.tol
end

function AlgorithmsInterface.get_reason(c::StopWhenStable, st::StopWhenStableState)
    (st.at_iteration &gt;= 0 &amp;&amp; st.delta &lt; c.tol) || return nothing
    return &quot;The algorithm reached an approximate stable point after $(st.at_iteration) iterations; the change $(st.delta) is less than $(c.tol).&quot;
end

AlgorithmsInterface.indicates_convergence(c::StopWhenStable, st::StopWhenStableState) = true</code></pre><h3 id="Convergence-in-action-2"><a class="docs-heading-anchor" href="#Convergence-in-action-2">Convergence in action</a><a class="docs-heading-anchor-permalink" href="#Convergence-in-action-2" title="Permalink"></a></h3><p>Again, we can inspect our work:</p><pre><code class="language-julia hljs">criterion = StopWhenStable(1e-8)
heron_sqrt(16.0; stopping_criterion = criterion)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(4.0, 11)</code></pre><p>Note that our work to ensure the correct interface payed off, as we can still compose this stopping criterion with other criteria as well:</p><pre><code class="language-julia hljs">criterion = StopWhenStable(1e-8) | StopAfterIteration(5)
heron_sqrt(16.0; stopping_criterion = criterion)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(4.000506331471994, 5)</code></pre><h3 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h3><p>Implementing a criterion usually means defining:</p><ol><li>A subtype of <a href="../interface/#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a>.</li><li>A state subtype of <a href="../interface/#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> capturing dynamic fields.</li><li><code>initialize_stopping_state</code> and <code>initialize_stopping_state!</code> for setup/reset.</li><li><code>is_finished!</code> (mutating) and optionally <code>is_finished</code> (non‑mutating) variants.</li><li><code>get_reason</code> (return <code>nothing</code> or a string) for user feedback.</li><li><code>indicates_convergence(::YourCriterion)</code> to mark if meeting it implies convergence.</li></ol><p>You may also implement <code>Base.summary(io, criterion, criterion_state)</code> for compact status reports.</p><h2 id="Reference-API"><a class="docs-heading-anchor" href="#Reference-API">Reference API</a><a id="Reference-API-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-API" title="Permalink"></a></h2><p>Below are the auto‑generated docs for all stopping criterion infrastructure.</p><article><details class="docstring"><summary id="AlgorithmsInterface.DefaultStoppingCriterionState"><a class="docstring-binding" href="#AlgorithmsInterface.DefaultStoppingCriterionState"><code>AlgorithmsInterface.DefaultStoppingCriterionState</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DefaultStoppingCriterionState &lt;: StoppingCriterionState</code></pre><p>A <a href="../interface/#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> that does not require any information besides storing the iteration number when it (last) indicated to stop).</p><p><strong>Field</strong></p><ul><li><code>at_iteration::Int</code> store the iteration number this state indicated to stop.<ul><li><code>0</code> means already at the start it indicated to stop</li><li>any negative number means that it did not yet indicate to stop.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/1a2fe42841387269c8c00e6def0bbe4b50a31d01/src/stopping_criterion.jl#L3-L14">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.GroupStoppingCriterionState"><a class="docstring-binding" href="#AlgorithmsInterface.GroupStoppingCriterionState"><code>AlgorithmsInterface.GroupStoppingCriterionState</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GroupStoppingCriterionState &lt;: StoppingCriterionState</code></pre><p>A <a href="../interface/#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> that groups multiple <a href="../interface/#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a>s internally as a tuple. This is for example used in combination with <a href="#AlgorithmsInterface.StopWhenAny"><code>StopWhenAny</code></a> and <a href="#AlgorithmsInterface.StopWhenAll"><code>StopWhenAll</code></a></p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">GroupStoppingCriterionState(c::Vector{&lt;:StoppingCriterionState})
GroupStoppingCriterionState(c::StoppingCriterionState...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/1a2fe42841387269c8c00e6def0bbe4b50a31d01/src/stopping_criterion.jl#L137-L147">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.StopAfter"><a class="docstring-binding" href="#AlgorithmsInterface.StopAfter"><code>AlgorithmsInterface.StopAfter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StopAfter &lt;: StoppingCriterion</code></pre><p>store a threshold when to stop looking at the complete runtime. It uses <code>time_ns()</code> to measure the time and you provide a <code>Period</code> as a time limit, for example <code>Minute(15)</code>.</p><p><strong>Fields</strong></p><ul><li><code>threshold</code> stores the <code>Period</code> after which to stop</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">StopAfter(t)</code></pre><p>initialize the stopping criterion to a <code>Period t</code> to stop after.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/1a2fe42841387269c8c00e6def0bbe4b50a31d01/src/stopping_criterion.jl#L368-L384">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.StopAfterIteration"><a class="docstring-binding" href="#AlgorithmsInterface.StopAfterIteration"><code>AlgorithmsInterface.StopAfterIteration</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StopAfterIteration &lt;: StoppingCriterion</code></pre><p>A simple stopping criterion to stop after a maximal number of iterations.</p><p><strong>Fields</strong></p><ul><li><code>max_iterations</code>  stores the maximal iteration number where to stop at</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">StopAfterIteration(maxIter)</code></pre><p>initialize the functor to indicate to stop after <code>maxIter</code> iterations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/1a2fe42841387269c8c00e6def0bbe4b50a31d01/src/stopping_criterion.jl#L304-L318">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.StopAfterTimePeriodState"><a class="docstring-binding" href="#AlgorithmsInterface.StopAfterTimePeriodState"><code>AlgorithmsInterface.StopAfterTimePeriodState</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StopAfterTimePeriodState &lt;: StoppingCriterionState</code></pre><p>A state for stopping criteria that are based on time measurements, for example <a href="#AlgorithmsInterface.StopAfter"><code>StopAfter</code></a>.</p><ul><li><code>start</code> stores the starting time when the algorithm is started, that is a call with <code>i=0</code>.</li><li><code>time</code> stores the elapsed time</li><li><code>at_iteration</code> indicates at which iteration (including <code>i=0</code>) the stopping criterion was fulfilled and is <code>-1</code> while it is not fulfilled.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/1a2fe42841387269c8c00e6def0bbe4b50a31d01/src/stopping_criterion.jl#L397-L408">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.StopWhenAll"><a class="docstring-binding" href="#AlgorithmsInterface.StopWhenAll"><code>AlgorithmsInterface.StopWhenAll</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StopWhenAll &lt;: StoppingCriterion</code></pre><p>store a tuple of <a href="../interface/#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a>s and indicate to stop, when <em>all</em> indicate to stop.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">StopWhenAll(c::NTuple{N,StoppingCriterion} where N)
StopWhenAll(c::StoppingCriterion,...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/1a2fe42841387269c8c00e6def0bbe4b50a31d01/src/stopping_criterion.jl#L36-L46">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.StopWhenAny"><a class="docstring-binding" href="#AlgorithmsInterface.StopWhenAny"><code>AlgorithmsInterface.StopWhenAny</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StopWhenAny &lt;: StoppingCriterion</code></pre><p>store an array of <a href="../interface/#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> elements and indicates to stop, when <em>any</em> single one indicates to stop. The <code>reason</code> is given by the concatenation of all reasons (assuming that all non-indicating return <code>&quot;&quot;</code>).</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">StopWhenAny(c::Vector{N,StoppingCriterion} where N)
StopWhenAny(c::StoppingCriterion...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/1a2fe42841387269c8c00e6def0bbe4b50a31d01/src/stopping_criterion.jl#L85-L96">source</a></section></details></article><article><details class="docstring"><summary id="Base.:&amp;-Tuple{StoppingCriterion, StoppingCriterion}"><a class="docstring-binding" href="#Base.:&amp;-Tuple{StoppingCriterion, StoppingCriterion}"><code>Base.:&amp;</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">&amp;(s1,s2)
s1 &amp; s2</code></pre><p>Combine two <a href="../interface/#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> within an <a href="#AlgorithmsInterface.StopWhenAll"><code>StopWhenAll</code></a>. If either <code>s1</code> (or <code>s2</code>) is already an <a href="#AlgorithmsInterface.StopWhenAll"><code>StopWhenAll</code></a>, then <code>s2</code> (or <code>s1</code>) is appended to the list of <a href="../interface/#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> within <code>s1</code> (or <code>s2</code>).</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">a = StopAfterIteration(200) &amp; StopAfter(Minute(1))</code></pre><p>Is the same as</p><pre><code class="nohighlight hljs">a = StopWhenAll(StopAfterIteration(200), StopAfter(Minute(1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/1a2fe42841387269c8c00e6def0bbe4b50a31d01/src/stopping_criterion.jl#L65-L79">source</a></section></details></article><article><details class="docstring"><summary id="Base.:|-Tuple{StoppingCriterion, StoppingCriterion}"><a class="docstring-binding" href="#Base.:|-Tuple{StoppingCriterion, StoppingCriterion}"><code>Base.:|</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">|(s1,s2)
s1 | s2</code></pre><p>Combine two <a href="../interface/#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> within an <a href="#AlgorithmsInterface.StopWhenAny"><code>StopWhenAny</code></a>. If either <code>s1</code> (or <code>s2</code>) is already an <a href="#AlgorithmsInterface.StopWhenAny"><code>StopWhenAny</code></a>, then <code>s2</code> (or <code>s1</code>) is appended to the list of <a href="../interface/#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> within <code>s1</code> (or <code>s2</code>)</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">a = StopAfterIteration(200) | StopAfter(Minute(1))</code></pre><p>Is the same as</p><pre><code class="nohighlight hljs">a = StopWhenAny(StopAfterIteration(200), StopAfter(Minute(1)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/1a2fe42841387269c8c00e6def0bbe4b50a31d01/src/stopping_criterion.jl#L116-L130">source</a></section></details></article><h3 id="Next:-Logging"><a class="docs-heading-anchor" href="#Next:-Logging">Next: Logging</a><a id="Next:-Logging-1"></a><a class="docs-heading-anchor-permalink" href="#Next:-Logging" title="Permalink"></a></h3><p>With halting logic done, proceed to the <a href="../logging/#sec_logging">logging section</a> to instrument the same example and capture intermediate diagnostics.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/">« Interface</a><a class="docs-footer-nextpage" href="../logging/">Logging »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 18 December 2025 15:19">Thursday 18 December 2025</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
