var documenterSearchIndex = {"docs":
[{"location":"references/#Literature","page":"References","title":"Literature","text":"This is all literature mentioned / referenced in the AlgorithmsInterface.jl documentation. Usually you find a small reference section at the end of every documentation page that contains the corresponding references as well.\n\n","category":"section"},{"location":"interface/#sec_interface","page":"Interface","title":"The algorithm interface","text":"This section starts a single, cohesive story that will weave through all documentation pages. We will incrementally build an iterative algorithm, enrich it with stopping criteria, and finally refine how it records (logs) its progress. Instead of presenting the API in the abstract, we anchor every concept in one concrete, tiny example you can copy & adapt.\n\nWhy an “interface” for algorithms? Iterative numerical methods nearly always share the same moving pieces:\n\nimmutable input (the mathematical problem you are solving),\nimmutable configuration (parameters and knobs of the chosen algorithm), and\nmutable working data (current iterate, caches, diagnostics) that evolves as you step.\n\nBundling these together loosely without forcing one giant monolithic type makes it easier to:\n\nreason about what is allowed to change and what must remain fixed,\nwrite generic tooling (e.g. stopping logic, logging, benchmarking) that applies across many algorithms,\ntest algorithms in isolation by constructing minimal Problem/Algorithm pairs, and\nextend behavior (add new stopping criteria, new logging events) without rewriting core loops.\n\nThe interface in this package formalizes those roles with three abstract types:\n\nProblem: immutable, algorithm‑agnostic input data.\nAlgorithm: immutable configuration and parameters deciding how to iterate.\nState: mutable data that evolves (current iterate, caches, counters, diagnostics).\n\nIt provides a framework for decomposing iterative methods into small, composable parts: concrete Problem/Algorithm/State types have to implement a minimal set of core functionality, and this package helps to stitch everything together and provide additional helper functionality such as stopping criteria and logging functionality.","category":"section"},{"location":"interface/#sec_heron","page":"Interface","title":"Concrete example: Heron's method","text":"To make everything tangible, we will work through a concrete example to illustrate the library's goals and concepts. Our running example is Heron's / Babylonian method for estimating sqrtS. (see also the concise background on Wikipedia: Babylonian method (Heron's method)): Starting from an initial guess x_0, we may converge to the solution by iterating:\n\nx_k+1 = frac12left(x_k + fracSx_kright)\n\nWe therefore suggest the following concrete implementations of the abstract types provided by this package: They are illustrative; various performance and generality questions will be left unaddressed to keep this example simple.","category":"section"},{"location":"interface/#Algorithm-types","page":"Interface","title":"Algorithm types","text":"using AlgorithmsInterface\n\nstruct SqrtProblem <: Problem\n    S::Float64                # number whose square root we seek\nend\n\nstruct HeronAlgorithm <: Algorithm\n    stopping_criterion        # will be plugged in later (any StoppingCriterion)\nend\n\nmutable struct HeronState <: State\n    iterate::Float64          # current iterate\n    iteration::Int            # current iteration count\n    stopping_criterion_state  # will be plugged in later (any StoppingCriterionState)\nend","category":"section"},{"location":"interface/#Initialization","page":"Interface","title":"Initialization","text":"In order to begin implementing the core parts of our algorithm, we start at the very beginning. There are two main entry points provided by the interface:\n\ninitialize_state constructs an entirely new state for the algorithm\ninitialize_state! (in-place) reset of an existing state.\n\nAn example implementation might look like:\n\nfunction AlgorithmsInterface.initialize_state(\n        problem::SqrtProblem, algorithm::HeronAlgorithm,\n        stopping_criterion_state::StoppingCriterionState;\n        kwargs...\n    )\n    x0 = rand()\n    iteration = 0\n    return HeronState(x0, 0, stopping_criterion_state)\nend\n\nfunction AlgorithmsInterface.initialize_state!(\n        problem::SqrtProblem, algorithm::HeronAlgorithm, state::HeronState;\n        kwargs...\n    )\n    state.iteration = 0\n    return state\nend","category":"section"},{"location":"interface/#Iteration-steps","page":"Interface","title":"Iteration steps","text":"Algorithms define a mutable step via step!. For Heron's method:\n\nfunction AlgorithmsInterface.step!(problem::SqrtProblem, algorithm::HeronAlgorithm, state::HeronState)\n    S = problem.S\n    x = state.iterate\n    state.iterate = 0.5 * (x + S / x)\n    return state\nend\n\nNote that we are only focussing on the actual algorithm, and not incrementing the iteration counter. These kinds of bookkeeping should be handled by the AlgorithmsInterface.increment! function, which will by default already increment the iteration counter. The following generic functionality is therefore enough for our purposes, and does not need to be defined. Nevertheless, if additional bookkeeping would be desired, this can be achieved by overloading that function:\n\nfunction AlgorithmsInterface.increment!(state::State)\n    state.iteration += 1\n    return state\nend","category":"section"},{"location":"interface/#Running-the-algorithm","page":"Interface","title":"Running the algorithm","text":"With these definitions in place you can already run (assuming you also choose a stopping criterion – added in the next section):\n\nfunction heron_sqrt(x; maxiter = 10)\n    prob = SqrtProblem(x)\n    alg  = HeronAlgorithm(StopAfterIteration(maxiter))\n    state = solve(prob, alg)  # allocates & runs\n    return state.iterate\nend\n\nprintln(\"Approximate sqrt: \", heron_sqrt(16.0))\n\nWe will refine this example with better halting logic and logging shortly.","category":"section"},{"location":"interface/#Reference:-Core-interface-types-and-functions","page":"Interface","title":"Reference: Core interface types & functions","text":"Below are the automatic API docs for the core interface pieces. Read them after grasping the example above – the intent should now be clearer.","category":"section"},{"location":"interface/#Algorithm","page":"Interface","title":"Algorithm","text":"","category":"section"},{"location":"interface/#Problem","page":"Interface","title":"Problem","text":"","category":"section"},{"location":"interface/#State","page":"Interface","title":"State","text":"","category":"section"},{"location":"interface/#Stopping-Criteria","page":"Interface","title":"Stopping Criteria","text":"","category":"section"},{"location":"interface/#Next:-Stopping-criteria","page":"Interface","title":"Next: Stopping criteria","text":"Proceed to the stopping criteria section to add robust halting logic (iteration caps, time limits, tolerance on successive iterates, and combinations) to this square‑root example.","category":"section"},{"location":"interface/#AlgorithmsInterface.initialize_state!-Tuple{Problem, Algorithm, State}","page":"Interface","title":"AlgorithmsInterface.initialize_state!","text":"state = initialize_state(\n    problem::Problem, algorithm::Algorithm,\n    [stopping_criterion_state::StoppingCriterionState];\n    kwargs...\n)\nstate = initialize_state!(\n    problem::Problem, algorithm::Algorithm, state::State;\n    kwargs...\n)\n\nInitialize a State based on a Problem and an Algorithm. The kwargs... should allow to initialize for example the initial point. This can be done in-place for state, then only values that did change have to be provided.\n\nNote that since the returned state should also hold state.stopping_criterion_state, which will be used to keep the internal state of the stopping criterion, the out-of-place version receives this as one of its arguments. By default, that will be initialized separately through a call to initialize_stopping_state and provided as an argument.\n\nOn the other hand, the in-place version is not responsible for initializing the stopping_criterion_state, as that will be handled separately by initialize_stopping_state!.\n\nUsers that which to handle the stopping criterion initialization in initialize_state manually should overload the 2-argument version, while by default the 3-argument version should be implemented.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.initialize_state-Tuple{Problem, Algorithm}","page":"Interface","title":"AlgorithmsInterface.initialize_state","text":"state = initialize_state(\n    problem::Problem, algorithm::Algorithm,\n    [stopping_criterion_state::StoppingCriterionState];\n    kwargs...\n)\nstate = initialize_state!(\n    problem::Problem, algorithm::Algorithm, state::State;\n    kwargs...\n)\n\nInitialize a State based on a Problem and an Algorithm. The kwargs... should allow to initialize for example the initial point. This can be done in-place for state, then only values that did change have to be provided.\n\nNote that since the returned state should also hold state.stopping_criterion_state, which will be used to keep the internal state of the stopping criterion, the out-of-place version receives this as one of its arguments. By default, that will be initialized separately through a call to initialize_stopping_state and provided as an argument.\n\nOn the other hand, the in-place version is not responsible for initializing the stopping_criterion_state, as that will be handled separately by initialize_stopping_state!.\n\nUsers that which to handle the stopping criterion initialization in initialize_state manually should overload the 2-argument version, while by default the 3-argument version should be implemented.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.solve!-Tuple{Problem, Algorithm, State}","page":"Interface","title":"AlgorithmsInterface.solve!","text":"solve!(problem::Problem, algorithm::Algorithm, state::State; kwargs...)\n\nSolve the Problem using an Algorithm, starting from a given State. The state is modified in-place.\n\nAll keyword arguments are passed to the initialize_state! and initialize_stopping_state! functions.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.solve-Tuple{Problem, Algorithm}","page":"Interface","title":"AlgorithmsInterface.solve","text":"solve(problem::Problem, algorithm::Algorithm; kwargs...)\n\nSolve the Problem using an Algorithm.\n\nThe keyword arguments kwargs... have to provide enough details such that the corresponding state and stopping state initialisation initialize_stateand [initializestoppingstate`](@ref) can be used to return valid states and stopping states.\n\nBy default this method continues to call solve!.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.step!-Tuple{Problem, Algorithm, State}","page":"Interface","title":"AlgorithmsInterface.step!","text":"step!(problem::Problem, algorithm::Algorithm, state::State)\n\nPerform the current step of an Algorithm solving a Problem modifying the algorithm's State.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.Algorithm","page":"Interface","title":"AlgorithmsInterface.Algorithm","text":"Algorithm\n\nAn abstract type to represent an algorithm.\n\nA concrete algorithm contains all static parameters that characterise the algorithms. Together with a Problem an Algorithm subtype should be able to initialize or reset a State.\n\nProperties\n\nAlgorithms can contain any number of properties that are needed to define the algorithm, but should additionally contain the following properties to interact with the stopping criteria.\n\nstopping_criterion::StoppingCriterion\n\nExample\n\nFor a gradient descent algorithm the algorithm would specify which step size selection to use.\n\n\n\n\n\n","category":"type"},{"location":"interface/#AlgorithmsInterface.Problem","page":"Interface","title":"AlgorithmsInterface.Problem","text":"Problem\n\nAn abstract type to represent a problem to be solved with all its static properties, that do not change during an algorithm run.\n\nExample\n\nFor a gradient descent algorithm the problem consists of\n\na cost function f C  ℝ\na gradient function operatornamegradf\n\nThe problem then could that these are given in four different forms\n\na function c = cost(x) and a gradient d = gradient(x)\na function c = cost(x) and an in-place gradient gradient!(d,x)\na combined cost-grad function (c,d) = costgrad(x)\na combined cost-grad function (c, d) = costgrad!(d, x) that computes the gradient in-place.\n\n\n\n\n\n","category":"type"},{"location":"interface/#AlgorithmsInterface.State","page":"Interface","title":"AlgorithmsInterface.State","text":"State\n\nAn abstract type to represent the state an iterative algorithm is in.\n\nThe state consists of any information that describes the current step the algorithm is in and keeps all information needed from one step to the next.\n\nProperties\n\nIn order to interact with the stopping criteria, the state should contain the following properties, and provide corresponding getproperty and setproperty! methods.\n\niteration – the current iteration step k that is is currently performed or was last performed\nstopping_criterion_state – a StoppingCriterionState that indicates whether an Algorithm will stop after this iteration or has stopped.\niterate the current iterate x^(k).\n\nMethods\n\nThe following methods should be implemented for a state\n\nincrement!(state)\n\n\n\n\n\n","category":"type"},{"location":"interface/#AlgorithmsInterface.increment!-Tuple{State}","page":"Interface","title":"AlgorithmsInterface.increment!","text":"increment!(state::State)\n\nIncrement the current iteration a State either is currently performing or was last performed\n\nThe default assumes that the current iteration is stored in state.iteration.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.StoppingCriterion","page":"Interface","title":"AlgorithmsInterface.StoppingCriterion","text":"StoppingCriterion\n\nAn abstract type to represent a stopping criterion of an Algorithm.\n\nA concrete StoppingCriterion should also implement a initialize_state(problem::Problem, algorithm::Algorithm, stopping_criterion::StoppingCriterion; kwargs...) function to create its accompanying StoppingCriterionState. as well as the corresponding mutating variant to reset such a StoppingCriterionState.\n\nIt should usually implement\n\nindicates_convergence(stopping_criterion)\nindicates_convergence(stopping_criterion, stopping_criterion_state)\nis_finished!(problem, algorithm, state, stopping_criterion, stopping_criterion_state)\nis_finished(problem, algorithm, state, stopping_criterion, stopping_criterion_state)\n\n\n\n\n\n","category":"type"},{"location":"interface/#AlgorithmsInterface.StoppingCriterionState","page":"Interface","title":"AlgorithmsInterface.StoppingCriterionState","text":"StoppingCriterionState\n\nAn abstract type to represent a stopping criterion state within a State. It represents the concrete state a StoppingCriterion is in.\n\nIt should usually implement\n\nget_reason(stopping_criterion, stopping_criterion_state)\nindicates_convergence(stopping_criterion, stopping_criterion_state)\nis_finished!(problem, algorithm, state, stopping_criterion, stopping_criterion_state)\nis_finished(problem, algorithm, state, stopping_criterion, stopping_criterion_state)\n\n\n\n\n\n","category":"type"},{"location":"interface/#AlgorithmsInterface.get_reason-Tuple{StoppingCriterion, StoppingCriterionState}","page":"Interface","title":"AlgorithmsInterface.get_reason","text":"get_reason(stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)\n\nProvide a reason in human readable text as to why a StoppingCriterion with StoppingCriterionState indicated to stop. If it does not indicate to stop, this should return nothing.\n\nProviding the iteration at which this indicated to stop in the reason would be preferable.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion, StoppingCriterionState}","page":"Interface","title":"AlgorithmsInterface.indicates_convergence","text":"indicates_convergence(stopping_criterion::StoppingCriterion, ::StoppingCriterionState)\n\nReturn whether or not a StoppingCriterion indicates convergence when it is in StoppingCriterionState.\n\nBy default this checks whether the StoppingCriterion has actually stopped. If so it returns whether stopping_criterion itself indicates convergence, otherwise it returns false, since the algorithm has then not yet stopped.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion}","page":"Interface","title":"AlgorithmsInterface.indicates_convergence","text":"indicates_convergence(stopping_criterion::StoppingCriterion)\n\nReturn whether or not a StoppingCriterion indicates convergence.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.initialize_stopping_state!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}","page":"Interface","title":"AlgorithmsInterface.initialize_stopping_state!","text":"stopping_criterion_state = initialize_stopping_state(\n    problem::Problem, algorithm::Algorithm\n    stopping_criterion::StoppingCriterion = algorithm.stopping_criterion;\n    kwargs...\n)\nstopping_criterion_state = initialize_stopping_state!(\n    problem::Problem, algorithm::Algorithm, state::State,\n    stopping_criterion::StoppingCriterion = algorithm.stopping_criterion,\n    stopping_criterion_state::StoppingCriterionState = state.stopping_criterion_state;\n    kwargs...\n)\n\nInitialize a StoppingCriterionState based on a Problem, Algorithm, State triplet for a given StoppingCriterion. By default, the stopping_criterion is retrieved from the Algorithm via algorithm.stopping_criterion.\n\nThe first signature is used for setting up a completely new stopping criterion state, while the second simply resets a given state in-place.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.initialize_stopping_state-Tuple{Problem, Algorithm, StoppingCriterion}","page":"Interface","title":"AlgorithmsInterface.initialize_stopping_state","text":"stopping_criterion_state = initialize_stopping_state(\n    problem::Problem, algorithm::Algorithm\n    stopping_criterion::StoppingCriterion = algorithm.stopping_criterion;\n    kwargs...\n)\nstopping_criterion_state = initialize_stopping_state!(\n    problem::Problem, algorithm::Algorithm, state::State,\n    stopping_criterion::StoppingCriterion = algorithm.stopping_criterion,\n    stopping_criterion_state::StoppingCriterionState = state.stopping_criterion_state;\n    kwargs...\n)\n\nInitialize a StoppingCriterionState based on a Problem, Algorithm, State triplet for a given StoppingCriterion. By default, the stopping_criterion is retrieved from the Algorithm via algorithm.stopping_criterion.\n\nThe first signature is used for setting up a completely new stopping criterion state, while the second simply resets a given state in-place.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}","page":"Interface","title":"AlgorithmsInterface.is_finished!","text":"is_finished(problem::Problem, algorithm::Algorithm, state::State)\nis_finished(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)\nis_finished!(problem::Problem, algorithm::Algorithm, state::State)\nis_finished!(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)\n\nIndicate whether an Algorithm solving Problem is finished having reached a certain State. The variant with three arguments by default extracts the StoppingCriterion and its StoppingCriterionState and their actual checks are performed in the implementation with five arguments.\n\nThe mutating variant does alter the stopping_criterion_state and and should only be called once per iteration, the other one merely inspects the current status without mutation.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State}","page":"Interface","title":"AlgorithmsInterface.is_finished!","text":"is_finished(problem::Problem, algorithm::Algorithm, state::State)\nis_finished(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)\nis_finished!(problem::Problem, algorithm::Algorithm, state::State)\nis_finished!(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)\n\nIndicate whether an Algorithm solving Problem is finished having reached a certain State. The variant with three arguments by default extracts the StoppingCriterion and its StoppingCriterionState and their actual checks are performed in the implementation with five arguments.\n\nThe mutating variant does alter the stopping_criterion_state and and should only be called once per iteration, the other one merely inspects the current status without mutation.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}","page":"Interface","title":"AlgorithmsInterface.is_finished","text":"is_finished(problem::Problem, algorithm::Algorithm, state::State)\nis_finished(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)\nis_finished!(problem::Problem, algorithm::Algorithm, state::State)\nis_finished!(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)\n\nIndicate whether an Algorithm solving Problem is finished having reached a certain State. The variant with three arguments by default extracts the StoppingCriterion and its StoppingCriterionState and their actual checks are performed in the implementation with five arguments.\n\nThe mutating variant does alter the stopping_criterion_state and and should only be called once per iteration, the other one merely inspects the current status without mutation.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State}","page":"Interface","title":"AlgorithmsInterface.is_finished","text":"is_finished(problem::Problem, algorithm::Algorithm, state::State)\nis_finished(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)\nis_finished!(problem::Problem, algorithm::Algorithm, state::State)\nis_finished!(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)\n\nIndicate whether an Algorithm solving Problem is finished having reached a certain State. The variant with three arguments by default extracts the StoppingCriterion and its StoppingCriterionState and their actual checks are performed in the implementation with five arguments.\n\nThe mutating variant does alter the stopping_criterion_state and and should only be called once per iteration, the other one merely inspects the current status without mutation.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Base.summary-Tuple{IO, StoppingCriterion, StoppingCriterionState}","page":"Interface","title":"Base.summary","text":"summary(io::IO, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)\n\nProvide a summary of the status of a stopping criterion – its parameters and whether it currently indicates to stop. It should not be longer than one line\n\nExample\n\nFor the StopAfterIteration criterion, the summary looks like\n\nMax Iterations (15): not reached\n\n\n\n\n\n","category":"method"},{"location":"stopping_criterion/#sec_stopping","page":"Stopping criteria","title":"Stopping criteria","text":"Continuing the square‑root story from the Interface page, we now decide when the iteration should halt. A stopping criterion encapsulates halting logic separately from the algorithm update rule.","category":"section"},{"location":"stopping_criterion/#Why-separate-stopping-logic?","page":"Stopping criteria","title":"Why separate stopping logic?","text":"Decoupling halting from stepping lets us:\n\nReuse generic stopping (iteration caps, time limits) across algorithms.\nCompose multiple conditions (stop after 1 second OR 100 iterations, etc.).\nQuery convergence indication vs. mere forced termination.\nStore structured reasons and state (e.g. at which iteration a threshold was met).","category":"section"},{"location":"stopping_criterion/#Built-in-criteria:-Heron's-method","page":"Stopping criteria","title":"Built-in criteria: Heron's method","text":"The package ships several concrete StoppingCriterions:\n\nStopAfterIteration: stop after a maximum number of iterations.\nStopAfter: stop after a wall‑clock time Period (e.g. Second(2), Minute(1)).\nCombinations StopWhenAll (logical AND) and StopWhenAny (logical OR) built via & and | operators.\n\nEach criterion has an associated StoppingCriterionState storing dynamic data (iteration when met, elapsed time, etc.).\n\nRecall our example implementation for Heron's method, where we we added a stopping_criterion to the Algorithm, as well as a stopping_criterion_state to the State.\n\nusing AlgorithmsInterface\n\nstruct SqrtProblem <: Problem\n    S::Float64                # number whose square root we seek\nend\n\nstruct HeronAlgorithm <: Algorithm\n    stopping_criterion        # any StoppingCriterion\nend\n\nmutable struct HeronState <: State\n    iterate::Float64          # current iterate\n    iteration::Int            # current iteration count\n    stopping_criterion_state  # any StoppingCriterionState\nend\n\nHere, we delve a bit deeper into the core components of what made our algorithm stop, even though we had to add very little additional functionality.","category":"section"},{"location":"stopping_criterion/#Initialization","page":"Stopping criteria","title":"Initialization","text":"The first core component to enable working with stopping criteria is to extend the initialization step to include initializing a StoppingCriterionState as well. Since some of these may require stateful implementations, we also keep a stopping_criterion_state that captures this, and thus needs to be initialized. By default, the initialization happens automatically and the only thing that is left for us to do is to attach this stopping_criterion_state to the state in the initialize_state function, as we already saw before:\n\nfunction AlgorithmsInterface.initialize_state(\n        problem::SqrtProblem, algorithm::HeronAlgorithm,\n        stopping_criterion_state::StoppingCriterionState;\n        kwargs...\n    )\n    x0 = rand()\n    iteration = 0\n    return HeronState(x0, 0, stopping_criterion_state)\nend\n\nfunction AlgorithmsInterface.initialize_state!(\n        problem::SqrtProblem, algorithm::HeronAlgorithm, state::HeronState;\n        kwargs...\n    )\n    state.iteration = 0\n    return state\nend\n\nNote that we do not need to handle any stopping criteria in the initialize_state! function, as a separate call to AlgorithmsInterface.initialize_stopping_state! is made independently.","category":"section"},{"location":"stopping_criterion/#Iteration","page":"Stopping criteria","title":"Iteration","text":"During the iteration procedure, as set out by our design principles, we do not have to modify any of the code, and the stopping criteria do not show up:\n\nfunction AlgorithmsInterface.step!(problem::SqrtProblem, algorithm::HeronAlgorithm, state::HeronState)\n    S = problem.S\n    x = state.iterate\n    state.iterate = 0.5 * (x + S / x)\n    return state\nend\n\nWhat is really going on is that behind the scenes, the loop of the iterative solver expands to code that is equivalent to:\n\nwhile !is_finished!(problem, algorithm,  state)\n    increment!(state)\n    step!(problem, algorithm, state)\nend\n\nIn other words, all of the logic is handled by the is_finished! function. The generic stopping criteria provided by this package have default implementations for this function that work out-of-the-box. This is partially because we used conventional names for the fields in the structs. There, Algorithm assumes the existence of stopping_criterion, while State assumes iterate and iteration and stopping_criterion_state to exist.","category":"section"},{"location":"stopping_criterion/#Running-the-algorithm","page":"Stopping criteria","title":"Running the algorithm","text":"We can again combine everything into a single function, but now make the stopping criterion accessible:\n\nfunction heron_sqrt(x; stopping_criterion)\n    prob = SqrtProblem(x)\n    alg  = HeronAlgorithm(stopping_criterion)\n    state = solve(prob, alg)  # allocates & runs\n    return state.iterate, state.iteration\nend\n\nheron_sqrt(2; stopping_criterion = StopAfterIteration(10))\n\nWith this function, we are now ready to explore different ways of telling the algorithm to stop. For example, using the basic criteria provided by this package, we can alternatively do:\n\nusing Dates\ncriterion = StopAfter(Millisecond(50))\nheron_sqrt(2; stopping_criterion = criterion)\n\nWe can tighten the condition by combining criteria. Suppose we want to stop after either 25 iterations or 50 milliseconds, whichever comes first:\n\ncriterion = StopAfterIteration(25) | StopAfter(Millisecond(50))  # logical OR\nheron_sqrt(2; stopping_criterion = criterion)\n\nConversely, to demand both a minimum iteration quality condition and a cap, use & (logical AND).\n\ncriterion = StopAfterIteration(25) & StopAfter(Millisecond(50))  # logical AND\nheron_sqrt(2; stopping_criterion = criterion)","category":"section"},{"location":"stopping_criterion/#Implementing-a-new-criterion","page":"Stopping criteria","title":"Implementing a new criterion","text":"It is of course possible that we are not satisfied by the stopping criteria that are provided by default. For example, we might check for convergence by squaring our current iterate and seeing if it equals the input value. In order to do so, we need to define our own struct and implement the required interface.\n\nstruct StopWhenSquared <: StoppingCriterion\n    tol::Float64    # when do we consider things to be converged\nend","category":"section"},{"location":"stopping_criterion/#Checking-for-convergence","page":"Stopping criteria","title":"Checking for convergence","text":"Then, we need to implement the logic that checks whether an algorithm has finished, which is achieved through is_finished and is_finished!.\n\nusing AlgorithmsInterface: DefaultStoppingCriterionState\n\nfunction AlgorithmsInterface.is_finished(\n        problem::SqrtProblem, ::Algorithm, state::State,\n        stopping_criterion::StopWhenSquared, ::DefaultStoppingCriterionState\n    )\n    return state.iteration > 0 && isapprox(state.iterate^2, problem.S; atol = stopping_criterion.tol)\nend\n\nNote that we automatically obtain a DefaultStoppingCriterionState as the final argument, in which we have to store the iteration at which convergence is reached. As this is a mutating operation that alters the stopping_criterion_state, we ensure that it is called exactly once per iteration, while the non-mutating version is simply used to inspect the current status.\n\nfunction AlgorithmsInterface.is_finished!(\n        problem::SqrtProblem, ::Algorithm, state::State,\n        stopping_criterion::StopWhenSquared, stopping_criterion_state::DefaultStoppingCriterionState\n    )\n    if state.iteration > 0 && isapprox(state.iterate^2, problem.S; atol = criterion.tol)\n        stopping_criterion_state.at_iteration = state.iteration\n        return true\n    else\n        return false\n    end\nend","category":"section"},{"location":"stopping_criterion/#Reason-and-convergence-reporting","page":"Stopping criteria","title":"Reason and convergence reporting","text":"Finally, we need to implement get_reason and indicates_convergence. These helper functions are required to interact with the logging system, to distinguish between states that are considered ongoing, stopped and converged, or stopped without convergence.\n\nfunction AlgorithmsInterface.get_reason(stopping_criterion::StopWhenSquared, stopping_criterion_state::DefaultStoppingCriterionState)\n    stopping_criterion_state.at_iteration >= 0 || return nothing\n    return \"The algorithm reached a square root after $(stopping_criterion_state.at_iteration) iterations up to a tolerance of $(stopping_criterion.tol).\"\nend\n\nAlgorithmsInterface.indicates_convergence(::StopWhenSquared, ::DefaultStoppingCriterionState) = true","category":"section"},{"location":"stopping_criterion/#Convergence-in-action","page":"Stopping criteria","title":"Convergence in action","text":"Then we are finally ready to test out our new stopping criteria.\n\ncriterion = StopWhenSquared(1e-8)\nheron_sqrt(16.0; stopping_criterion = criterion)","category":"section"},{"location":"stopping_criterion/#Initialization-2","page":"Stopping criteria","title":"Initialization","text":"Now suppose we want to stop when successive iterates change by less than ϵ. This can be achieved by introducing a new stopping criterion again, but now we have to retain the previous iterate in order to have something to compare against. Similar to the algorithm State, we split up the data into a static part, the StoppingCriterion, and a dynamic part, the StoppingCriterionState.\n\nstruct StopWhenStable <: StoppingCriterion\n    tol::Float64    # when do we consider things converged\nend\n\nmutable struct StopWhenStableState <: StoppingCriterionState\n    previous_iterate::Float64       # previous value to compare to\n    at_iteration::Int               # iteration at which stability was reached\n    delta::Float64                  # difference between the values\nend\n\nNote that our mutable state holds both the previous_iterate, which we need to compare to, as well as the iteration at which the condition was satisfied. This is not strictly necessary, but can be convenient to have a persistent indication that convergence was reached.\n\nIn order to support these stateful criteria, again an initialization phase is needed. The relevant functions are now:\n\nAlgorithmsInterface.initialize_stopping_state\nAlgorithmsInterface.initialize_stopping_state!\n\nThis could be implemented as follows:\n\nfunction AlgorithmsInterface.initialize_stopping_state(\n        ::Problem, ::Algorithm,\n        stopping_criterion::StopWhenStable;\n        kwargs...\n    )\n    return StopWhenStableState(NaN, -1, NaN)\nend\n\nfunction AlgorithmsInterface.initialize_stopping_state!(\n        ::Problem, ::Algorithm, ::State,\n        stopping_criterion::StopWhenStable,\n        stopping_criterion_state::StopWhenStableState;\n        kwargs...\n    )\n    stopping_criterion_state.previous_iterate = NaN\n    stopping_criterion_state.at_iteration = -1\n    stopping_criterion_state.delta = NaN\n    return stopping_criterion_state\nend\n\nnote: Note\nWhile for this simple case this does not matter, note that there is a subtle detail associated to the initialization order of the State and StoppingCriterionState respectively. For the first initialization, AlgorithmsInterface.initialize_stopping_state is called before initialize_state. This is required since the State encapsulates the StoppingCriterionState. On the other hand, during the solver, the AlgorithmsInterface.initialize_stopping_state! is called before initialize_state. This can be important for example to ensure that the initialization time of the state is taken into account for the stopping criteria.\n\nThe remainder of the implementation follows straightforwardly, where we again take care to only mutate the stopping_criterion_state in the mutating is_finished! implementation.\n\nfunction AlgorithmsInterface.is_finished!(\n        ::Problem, ::Algorithm, state::State, c::StopWhenStable, st::StopWhenStableState\n    )\n\n\tk = state.iteration\n\tif k == 0\n\t\tst.previous_iterate = state.iterate\n\t\tst.at_iteration = -1\n\t\treturn false\n\tend\n\n\tst.delta = abs(state.iterate - st.previous_iterate)\n\tst.previous_iterate = state.iterate\n\tif st.delta < c.tol\n\t\tst.at_iteration = k\n\t\treturn true\n\tend\n\treturn false\nend\n\nfunction AlgorithmsInterface.is_finished(\n        ::Problem, ::Algorithm, state::State, c::StopWhenStable, st::StopWhenStableState\n    )\n\tk = state.iteration\n\tk == 0 && return false\n\n\tΔ = abs(state.iterate - st.previous_iterate)\n\treturn Δ < c.tol\nend\n\nfunction AlgorithmsInterface.get_reason(c::StopWhenStable, st::StopWhenStableState)\n    (st.at_iteration >= 0 && st.delta < c.tol) || return nothing\n    return \"The algorithm reached an approximate stable point after $(st.at_iteration) iterations; the change $(st.delta) is less than $(c.tol).\"\nend\n\nAlgorithmsInterface.indicates_convergence(c::StopWhenStable, st::StopWhenStableState) = true","category":"section"},{"location":"stopping_criterion/#Convergence-in-action-2","page":"Stopping criteria","title":"Convergence in action","text":"Again, we can inspect our work:\n\ncriterion = StopWhenStable(1e-8)\nheron_sqrt(16.0; stopping_criterion = criterion)\n\nNote that our work to ensure the correct interface payed off, as we can still compose this stopping criterion with other criteria as well:\n\ncriterion = StopWhenStable(1e-8) | StopAfterIteration(5)\nheron_sqrt(16.0; stopping_criterion = criterion)","category":"section"},{"location":"stopping_criterion/#Summary","page":"Stopping criteria","title":"Summary","text":"Implementing a criterion usually means defining:\n\nA subtype of StoppingCriterion.\nA state subtype of StoppingCriterionState capturing dynamic fields.\ninitialize_stopping_state and initialize_stopping_state! for setup/reset.\nis_finished! (mutating) and optionally is_finished (non‑mutating) variants.\nget_reason (return nothing or a string) for user feedback.\nindicates_convergence(::YourCriterion) to mark if meeting it implies convergence.\n\nYou may also implement Base.summary(io, criterion, criterion_state) for compact status reports.","category":"section"},{"location":"stopping_criterion/#Reference-API","page":"Stopping criteria","title":"Reference API","text":"Below are the auto‑generated docs for all stopping criterion infrastructure.","category":"section"},{"location":"stopping_criterion/#Next:-Logging","page":"Stopping criteria","title":"Next: Logging","text":"With halting logic done, proceed to the logging section to instrument the same example and capture intermediate diagnostics.","category":"section"},{"location":"stopping_criterion/#AlgorithmsInterface.DefaultStoppingCriterionState","page":"Stopping criteria","title":"AlgorithmsInterface.DefaultStoppingCriterionState","text":"DefaultStoppingCriterionState <: StoppingCriterionState\n\nA StoppingCriterionState that does not require any information besides storing the iteration number when it (last) indicated to stop).\n\nField\n\nat_iteration::Int store the iteration number this state indicated to stop.\n0 means already at the start it indicated to stop\nany negative number means that it did not yet indicate to stop.\n\n\n\n\n\n","category":"type"},{"location":"stopping_criterion/#AlgorithmsInterface.GroupStoppingCriterionState","page":"Stopping criteria","title":"AlgorithmsInterface.GroupStoppingCriterionState","text":"GroupStoppingCriterionState <: StoppingCriterionState\n\nA StoppingCriterionState that groups multiple StoppingCriterionStates internally as a tuple. This is for example used in combination with StopWhenAny and StopWhenAll\n\nConstructor\n\nGroupStoppingCriterionState(c::Vector{<:StoppingCriterionState})\nGroupStoppingCriterionState(c::StoppingCriterionState...)\n\n\n\n\n\n","category":"type"},{"location":"stopping_criterion/#AlgorithmsInterface.StopAfter","page":"Stopping criteria","title":"AlgorithmsInterface.StopAfter","text":"StopAfter <: StoppingCriterion\n\nstore a threshold when to stop looking at the complete runtime. It uses time_ns() to measure the time and you provide a Period as a time limit, for example Minute(15).\n\nFields\n\nthreshold stores the Period after which to stop\n\nConstructor\n\nStopAfter(t)\n\ninitialize the stopping criterion to a Period t to stop after.\n\n\n\n\n\n","category":"type"},{"location":"stopping_criterion/#AlgorithmsInterface.StopAfterIteration","page":"Stopping criteria","title":"AlgorithmsInterface.StopAfterIteration","text":"StopAfterIteration <: StoppingCriterion\n\nA simple stopping criterion to stop after a maximal number of iterations.\n\nFields\n\nmax_iterations  stores the maximal iteration number where to stop at\n\nConstructor\n\nStopAfterIteration(maxIter)\n\ninitialize the functor to indicate to stop after maxIter iterations.\n\n\n\n\n\n","category":"type"},{"location":"stopping_criterion/#AlgorithmsInterface.StopAfterTimePeriodState","page":"Stopping criteria","title":"AlgorithmsInterface.StopAfterTimePeriodState","text":"StopAfterTimePeriodState <: StoppingCriterionState\n\nA state for stopping criteria that are based on time measurements, for example StopAfter.\n\nstart stores the starting time when the algorithm is started, that is a call with i=0.\ntime stores the elapsed time\nat_iteration indicates at which iteration (including i=0) the stopping criterion was fulfilled and is -1 while it is not fulfilled.\n\n\n\n\n\n","category":"type"},{"location":"stopping_criterion/#AlgorithmsInterface.StopWhenAll","page":"Stopping criteria","title":"AlgorithmsInterface.StopWhenAll","text":"StopWhenAll <: StoppingCriterion\n\nstore a tuple of StoppingCriterions and indicate to stop, when all indicate to stop.\n\nConstructor\n\nStopWhenAll(c::NTuple{N,StoppingCriterion} where N)\nStopWhenAll(c::StoppingCriterion,...)\n\n\n\n\n\n","category":"type"},{"location":"stopping_criterion/#AlgorithmsInterface.StopWhenAny","page":"Stopping criteria","title":"AlgorithmsInterface.StopWhenAny","text":"StopWhenAny <: StoppingCriterion\n\nstore an array of StoppingCriterion elements and indicates to stop, when any single one indicates to stop. The reason is given by the concatenation of all reasons (assuming that all non-indicating return \"\").\n\nConstructors\n\nStopWhenAny(c::Vector{N,StoppingCriterion} where N)\nStopWhenAny(c::StoppingCriterion...)\n\n\n\n\n\n","category":"type"},{"location":"stopping_criterion/#Base.:&-Tuple{StoppingCriterion, StoppingCriterion}","page":"Stopping criteria","title":"Base.:&","text":"&(s1,s2)\ns1 & s2\n\nCombine two StoppingCriterion within an StopWhenAll. If either s1 (or s2) is already an StopWhenAll, then s2 (or s1) is appended to the list of StoppingCriterion within s1 (or s2).\n\nExample\n\na = StopAfterIteration(200) & StopAfter(Minute(1))\n\nIs the same as\n\na = StopWhenAll(StopAfterIteration(200), StopAfter(Minute(1))\n\n\n\n\n\n","category":"method"},{"location":"stopping_criterion/#Base.:|-Tuple{StoppingCriterion, StoppingCriterion}","page":"Stopping criteria","title":"Base.:|","text":"|(s1,s2)\ns1 | s2\n\nCombine two StoppingCriterion within an StopWhenAny. If either s1 (or s2) is already an StopWhenAny, then s2 (or s1) is appended to the list of StoppingCriterion within s1 (or s2)\n\nExample\n\na = StopAfterIteration(200) | StopAfter(Minute(1))\n\nIs the same as\n\na = StopWhenAny(StopAfterIteration(200), StopAfter(Minute(1)))\n\n\n\n\n\n","category":"method"},{"location":"logging/#sec_logging","page":"Logging","title":"Logging","text":"In the final part of the square‑root story we augment Heron's iteration with logging functionality. For example, we might be interested in the convergence behavior throughout the iterations, timing information, or storing intermediate values for later analysis. The logging system is designed to provide full flexibility over this behavior, without polluting the core algorithm implementation. Additionally, we strive to pay for what you get: when no logging is configured, there is minimal overhead.","category":"section"},{"location":"logging/#Why-separate-logging-from-algorithms?","page":"Logging","title":"Why separate logging from algorithms?","text":"Decoupling logging from algorithm logic lets us:\n\nAdd diagnostic output without modifying algorithm code.\nCompose multiple logging behaviors (printing, storing, timing) independently.\nReuse generic logging actions across different algorithms.\nDisable logging globally with zero runtime cost.\nInstrument algorithms with custom events for domain-specific diagnostics.\nCustomize logging behavior a posteriori: users can add logging features to existing algorithms without modifying library code.\n\nThe logging system aims to achieve these goals by separating the logging logic into two separate parts. These parts can be roughly described as events and actions, where the logging system is responsible for mapping between them. Concretely, we have:\n\nWhen do we log? → an with_algorithmlogger to control how to map events to actions.\nWhat happens when we log? → a LoggingAction to determine what to do when an event happens.\n\nThis separation allows users to compose rich behaviors (printing, collecting statistics, plotting) without modifying algorithm code, and lets algorithm authors emit domain‑specific events.","category":"section"},{"location":"logging/#Using-the-default-logging-actions","page":"Logging","title":"Using the default logging actions","text":"Continuing from the Stopping Criteria page, we have our Heron's method implementation ready:\n\nusing AlgorithmsInterface\nusing Printf\nusing Dates # hide\n\nstruct SqrtProblem <: Problem\n    S::Float64\nend\n\nstruct HeronAlgorithm <: Algorithm\n    stopping_criterion\nend\n\nmutable struct HeronState <: State\n    iterate::Float64\n    iteration::Int\n    stopping_criterion_state\nend\n\nfunction AlgorithmsInterface.initialize_state(\n        problem::SqrtProblem, algorithm::HeronAlgorithm,\n        stopping_criterion_state::StoppingCriterionState;\n        kwargs...\n    )\n    x0 = rand()\n    iteration = 0\n    return HeronState(x0, 0, stopping_criterion_state)\nend\n\nfunction AlgorithmsInterface.initialize_state!(\n        problem::SqrtProblem, algorithm::HeronAlgorithm, state::HeronState;\n        kwargs...\n    )\n    state.iteration = 0\n    return state\nend\n\nfunction AlgorithmsInterface.step!(problem::SqrtProblem, algorithm::HeronAlgorithm, state::HeronState)\n    S = problem.S\n    x = state.iterate\n    state.iterate = 0.5 * (x + S / x)\n    return state\nend\n\nfunction heron_sqrt(x; stopping_criterion = StopAfterIteration(10))\n    prob = SqrtProblem(x)\n    alg  = HeronAlgorithm(stopping_criterion)\n    state = solve(prob, alg)  # allocates & runs\n    return state.iterate\nend\nnothing # hide\n\nIt is already interesting to note that there are no further modifications necessary to start leveraging the logging system.","category":"section"},{"location":"logging/#Basic-iteration-printing","page":"Logging","title":"Basic iteration printing","text":"Let's start with a very basic example of logging: printing iteration information after each step. We use CallbackAction to wrap a simple function that accesses the state, and prints the iteration as well as the iterate.\n\nusing Printf\niter_printer = CallbackAction() do problem, algorithm, state\n    @printf(\"Iter %3d: x = %.12f\\n\", state.iteration, state.iterate)\nend\nnothing # hide\n\nTo activate this logger, we wrap the section of code that we want to enable logging for, and map the :PostStep context to our action. This is achieved through the with_algorithmlogger function, which under the hood uses Julia's with function to manipulate a scoped value.\n\nwith_algorithmlogger(:PostStep => iter_printer) do\n    sqrt2 = heron_sqrt(2.0)\nend\nnothing # hide","category":"section"},{"location":"logging/#Default-logging-contexts","page":"Logging","title":"Default logging contexts","text":"The default solve! loop emits logging events at several key points during iteration:\n\ncontext event\n:Start The solver will start.\n:PreStep The solver is about to take a step.\n:PostStep The solver has taken a step.\n:Stop The solver has finished.\n\nAny of these events can be hooked into to attach a logging action. For example, we may expand on the previous example as follows:\n\nstart_printer = CallbackAction() do problem, algorithm, state\n    @printf(\"Start: x = %.12f\\n\", state.iterate)\nend\nstop_printer = CallbackAction() do problem, algorithm, state\n    @printf(\"Stop %3d: x = %.12f\\n\", state.iteration, state.iterate)\nend\n\nwith_algorithmlogger(:Start => start_printer, :PostStep => iter_printer, :Stop => stop_printer) do\n    sqrt2 = heron_sqrt(2.0)\nend\nnothing # hide\n\nFurthermore, specific algorithms could emit events for custom contexts too. We will come back to this in the section on the AlgorithmLogger design.","category":"section"},{"location":"logging/#Timing-execution","page":"Logging","title":"Timing execution","text":"Let's add timing information to see how long each iteration takes:\n\nstart_time = Ref{Float64}(0.0)\n\nrecord_start = CallbackAction() do problem, algorithm, state\n    start_time[] = time()\nend\n\nshow_elapsed = CallbackAction() do problem, algorithm, state\n    dt = time() - start_time[]\n    @printf(\"  elapsed = %.3fs\\n\", dt)\nend\n\nwith_algorithmlogger(\n    :Start => record_start,\n    :PostStep => show_elapsed,\n    :Stop => CallbackAction() do problem, algorithm, state\n        total = time() - start_time[]\n        @printf(\"Done after %d iterations (total %.3fs)\\n\", state.iteration, total)\n    end,\n) do\n    sqrt2 = heron_sqrt(2)\nend\nnothing # hide","category":"section"},{"location":"logging/#Conditional-logging","page":"Logging","title":"Conditional logging","text":"Sometimes we only want to log at specific iterations. IfAction wraps another action behind a predicate:\n\nevery_two = IfAction(\n    (problem, algorithm, state; kwargs...) -> state.iteration % 2 == 0,\n    iter_printer,\n)\n\nwith_algorithmlogger(:PostStep => every_two) do\n    sqrt2 = heron_sqrt(2)\nend\nnothing # hide\n\nThis prints only on even iterations, reducing output for long-running algorithms.","category":"section"},{"location":"logging/#Storing-intermediate-values","page":"Logging","title":"Storing intermediate values","text":"Instead of just printing, we can capture the entire trajectory for later analysis:\n\nstruct CaptureHistory <: LoggingAction\n    iterates::Vector{Float64}\nend\nCaptureHistory() = CaptureHistory(Float64[])\n\nfunction AlgorithmsInterface.handle_message!(\n        action::CaptureHistory,\n        problem::SqrtProblem,\n        algorithm::HeronAlgorithm,\n        state::HeronState;\n        kwargs...\n)\n    push!(action.iterates, state.iterate)\n    return nothing\nend\n\nhistory = CaptureHistory()\n\nwith_algorithmlogger(:PostStep => history) do\n    sqrt2 = heron_sqrt(2)\nend\n\nprintln(\"Stored \", length(history.iterates), \" iterates\")\nprintln(\"First few values: \", history.iterates[1:min(3, end)])\n\nYou can later analyze convergence rates, plot trajectories, or export data—all without modifying the algorithm.","category":"section"},{"location":"logging/#Combining-multiple-logging-behaviors","page":"Logging","title":"Combining multiple logging behaviors","text":"We can combine printing, timing, and storage simultaneously:\n\nhistory2 = CaptureHistory()\n\nwith_algorithmlogger(\n    :Start => record_start,\n    :PostStep => ActionGroup(iter_printer, history2),\n    :Stop => CallbackAction() do problem, algorithm, state\n        @printf(\"Captured %d iterates in %.3fs\\n\", length(history2.iterates), time() - start_time[])\n    end,\n) do\n    sqrt2 = heron_sqrt(2)\nend\nnothing # hide","category":"section"},{"location":"logging/#Implementing-custom-LoggingActions","page":"Logging","title":"Implementing custom LoggingActions","text":"While CallbackAction is convenient for quick instrumentation, custom types give more control and possibly better performance. Let's implement a more sophisticated example: tracking iteration statistics.","category":"section"},{"location":"logging/#The-required-interface","page":"Logging","title":"The required interface","text":"To implement a custom LoggingAction, you need:\n\nA concrete subtype of LoggingAction.\nAn implementation of AlgorithmsInterface.handle_message! that defines the behavior.\n\nThe signature of handle_message! is:\n\nfunction handle_message!(\n        action::YourAction, problem::Problem, algorithm::Algorithm, state::State; kwargs...\n)\n    # Your logging logic here\n    return nothing\nend\n\nThe kwargs... can contain context-specific information, though the default contexts don't currently pass additional data.","category":"section"},{"location":"logging/#Example:-Statistics-collector","page":"Logging","title":"Example: Statistics collector","text":"Let's build an action that tracks statistics across iterations:\n\nmutable struct StatsCollector <: LoggingAction\n    count::Int              # aggregate number of evaluations\n    sum::Float64            # sum of all intermediate values\n    sum_squares::Float64    # square sum of all intermediate values\nend\nStatsCollector() = StatsCollector(0, 0.0, 0.0)\n\nfunction AlgorithmsInterface.handle_message!(\n        action::StatsCollector, problem::SqrtProblem, algorithm::HeronAlgorithm, state::HeronState;\n        kwargs...\n)\n    action.count += 1\n    action.sum += state.iterate\n    action.sum_squares += state.iterate^2\n    return nothing\nend\n\nfunction compute_stats(stats::StatsCollector)\n    n = stats.count\n    mean = stats.sum / n\n    variance = (stats.sum_squares / n) - mean^2\n    return (mean=mean, variance=variance, count=n)\nend\n\nstats = StatsCollector()\n\nwith_algorithmlogger(:PostStep => stats) do\n    sqrt2 = heron_sqrt(2.0; stopping_criterion = StopAfter(Millisecond(50)))\nend\n\nresult = compute_stats(stats)\nprintln(\"Collected $(result.count) samples\")\nprintln(\"Mean iterate: $(result.mean)\")\nprintln(\"Variance: $(result.variance)\")\n\nThis pattern of collecting data during iteration and post-processing afterward is efficient and keeps the hot loop fast.","category":"section"},{"location":"logging/#sec_algorithmlogger","page":"Logging","title":"The AlgorithmLogger","text":"The AlgorithmsInterface.AlgorithmLogger is the dispatcher that routes logging events to actions. Understanding its design helps when adding custom logging contexts.","category":"section"},{"location":"logging/#How-logging-events-are-emitted","page":"Logging","title":"How logging events are emitted","text":"Inside the solve! function, logging events are emitted at key points:\n\nfunction solve!(problem::Problem, algorithm::Algorithm, state::State; kwargs...)\n    initialize_state!(problem, algorithm, state; kwargs...)\n    emit_message(problem, algorithm, state, :Start)\n    \n    while !is_finished!(problem, algorithm, state)\n        emit_message(problem, algorithm, state, :PreStep)\n        \n        increment!(state)\n        step!(problem, algorithm, state)\n        \n        emit_message(problem, algorithm, state, :PostStep)\n    end\n    \n    emit_message(problem, algorithm, state, :Stop)\n    \n    return state\nend\n\nThe emit_message function looks up the context (e.g., :PostStep) in the logger's action dictionary and calls handle_message! on the corresponding action.","category":"section"},{"location":"logging/#Global-enable/disable","page":"Logging","title":"Global enable/disable","text":"For production runs or benchmarking, you can disable all logging globally:\n\n# By default, logging is enabled:\nprintln(\"Logging enabled: \", AlgorithmsInterface.get_global_logging_state())\nwith_algorithmlogger(:PostStep => iter_printer) do\n    heron_sqrt(2.0)\nend\nnothing # hide\n\n# But, logging can also be disabled:\nprevious_state = AlgorithmsInterface.set_global_logging_state!(false)\n\n# This will not log anything, even with a logger configured\nwith_algorithmlogger(:PostStep => iter_printer) do\n    heron_sqrt(2.0)\nend\n\n# Restore previous state\nAlgorithmsInterface.set_global_logging_state!(previous_state)\nnothing # hide\n\nThis works since the default implementation of emit_message first retrieves the current logger through AlgorithmsInterface.algorithm_logger:\n\nemit_message(problem, algorithm, state, context; kwargs...) =\n    emit_message(algorithm_logger(), problem, algorithm, state, context; kwargs...)\n\nWhen logging is disabled globally, algorithm_logger returns nothing, and emit_message becomes a no-op with minimal overhead.","category":"section"},{"location":"logging/#Error-isolation","page":"Logging","title":"Error isolation","text":"If a LoggingAction throws an exception, the logging system catches it and reports an error without aborting the algorithm:\n\nbuggy_action = CallbackAction() do problem, algorithm, state\n    if state.iteration == 3\n        error(\"Intentional logging error at iteration 3\")\n    end\n    @printf(\"Iter %d\\n\", state.iteration)\nend\n\nwith_algorithmlogger(:PostStep => buggy_action) do\n    heron_sqrt(2.0)\n    println(\"Algorithm completed despite logging error\")\nend\n\nThis robustness ensures that bugs in logging code don't compromise the algorithm's correctness.","category":"section"},{"location":"logging/#Adding-custom-logging-contexts","page":"Logging","title":"Adding custom logging contexts","text":"Algorithms can emit custom logging events for domain-specific scenarios. For example, adaptive algorithms might emit events when step sizes are reduced, or when steps are rejected. Here we will illustrate this by a slight adaptation of our algorithm, which could restart if convergence wasn't reached after 10 iterations.","category":"section"},{"location":"logging/#Emitting-custom-events","page":"Logging","title":"Emitting custom events","text":"To emit a custom logging event from within your algorithm, call emit_message:\n\nfunction AlgorithmsInterface.step!(problem::SqrtProblem, algorithm::HeronAlgorithm, state::HeronState)\n    # Suppose we check for numerical issues\n    if !isfinite(state.iterate) || mod(state.iteration, 10) == 0\n        emit_message(problem, algorithm, state, :Restart)\n        state.iterate = rand()  # Reset the iterate an try again\n    end\n    \n    # Normal step\n    S = problem.S\n    x = state.iterate\n    state.iterate = 0.5 * (x + S / x)\n    return state\nend\nnothing # hide\n\nNow users can attach actions to the :Restart context:\n\nissue_counter = Ref(0)\nissue_action = CallbackAction() do problem, algorithm, state\n    issue_counter[] += 1\n    println(\"⚠️  Numerical issue detected at iteration \", state.iteration)\nend\n\nwith_algorithmlogger(:Restart => issue_action, :PostStep => iter_printer) do\n    sqrt2 = heron_sqrt(2.0; stopping_criterion = StopAfterIteration(30))\nend\n\nnothing # hide","category":"section"},{"location":"logging/#Best-practices","page":"Logging","title":"Best practices","text":"","category":"section"},{"location":"logging/#Performance-considerations","page":"Logging","title":"Performance considerations","text":"Logging actions may be fast or slow, since the overhead is only incurred when actually using them.\nAlgorithms should be mindful of emitting events in hot loops. These events incur an overhead similar to accessing a ScopedValue (~10-100 ns), even when no logging action is registered.\nFor expensive operations (plotting, I/O), it is often better to collect data during iteration and process afterward.\nUse set_global_logging_state!(false) for production benchmarks.","category":"section"},{"location":"logging/#Guidelines-for-custom-actions","page":"Logging","title":"Guidelines for custom actions","text":"When designing custom logging actions for your algorithms:\n\nIt is good practice to avoid modifying the algorithm state, as this might leave the algorithm in an invalid state to continue running.\nThe logging state and global state can be mutated as you see fit, but be mindful of properly initializing and resetting the state if so desired.\nIf you need to influence the algorithm, use stopping criteria or modify the algorithm itself.\nFor generic and reusable actions, document which properties they access from the problem, algorithm, state triplet, and be prepared to handle cases where these aren't present.","category":"section"},{"location":"logging/#Guidelines-for-custom-contexts","page":"Logging","title":"Guidelines for custom contexts","text":"When designing custom logging contexts for your algorithms:\n\nUse descriptive symbol names (:LineSearchFailed, :StepRejected, :Refined).\nDocument which contexts your algorithm emits and when.\nKeep context-specific data in kwargs... if needed (though the default contexts don't use this).\nEmit events at meaningful decision points, not in tight inner loops.","category":"section"},{"location":"logging/#Summary","page":"Logging","title":"Summary","text":"Implementing logging involves three main components:\n\nLoggingAction: Define what happens when a logging event occurs.\nUse CallbackAction for quick inline functions.\nImplement custom subtypes for reusable, stateful logging.\nImplement handle_message!(action, problem, algorithm, state; kwargs...).\nAlgorithmLogger: Map contexts (:Start, :PostStep, etc.) to actions.\nConstruct with with_algorithmlogger(:Context => action, ...).\nUse ActionGroup to compose multiple actions at one context.\nCustom contexts: Emit domain-specific events from algorithms.\nCall emit_message(problem, algorithm, state, :YourContext).\nDocument custom contexts in your algorithm's documentation.\nUse descriptive symbol names.\n\nThe logging system is designed for composability and zero-overhead when disabled, letting you instrument algorithms without compromising performance or code clarity.","category":"section"},{"location":"logging/#Reference-API","page":"Logging","title":"Reference API","text":"Auto‑generated documentation for logging infrastructure follows.","category":"section"},{"location":"logging/#Wrap‑up","page":"Logging","title":"Wrap‑up","text":"You have now seen the three pillars of the AlgorithmsInterface:\n\nInterface: Defining algorithms with Problem, Algorithm, and State.\nStopping criteria: Controlling when iteration halts with composable conditions.\nLogging: Instrumenting execution with flexible, composable actions.\n\nTogether, these patterns encourage modular, testable, and maintainable iterative algorithm design. You can now build algorithms that are easy to configure, monitor, and extend without invasive modifications to core logic.","category":"section"},{"location":"logging/#AlgorithmsInterface.ActionGroup","page":"Logging","title":"AlgorithmsInterface.ActionGroup","text":"ActionGroup(actions::LoggingAction...)\nActionGroup(actions::Vector{<:LoggingAction})\n\nConcrete LoggingAction that can be used to sequentially perform each of the actions.\n\n\n\n\n\n","category":"type"},{"location":"logging/#AlgorithmsInterface.AlgorithmLogger","page":"Logging","title":"AlgorithmsInterface.AlgorithmLogger","text":"AlgorithmLogger(context => action, ...) -> logger\n\nLogging transformer that handles the logic of dispatching logging events to logging actions. This is implemented through logger[context].\n\nSee also the scoped value AlgorithmsInterface.algorithm_logger.\n\n\n\n\n\n","category":"type"},{"location":"logging/#AlgorithmsInterface.CallbackAction","page":"Logging","title":"AlgorithmsInterface.CallbackAction","text":"CallbackAction(callback)\n\nConcrete LoggingAction that handles a logging event through an arbitrary callback function. The callback function must have the following signature:\n\ncallback(problem, algorithm, state; kwargs...) = ...\n\nHere kwargs... are optional and can be filled out with context-specific information.\n\n\n\n\n\n","category":"type"},{"location":"logging/#AlgorithmsInterface.IfAction","page":"Logging","title":"AlgorithmsInterface.IfAction","text":"IfAction(predicate, action)\n\nConcrete LoggingAction that wraps another action and hides it behind a clause, only emitting logging events whenever the predicate evaluates to true. The predicate must have the signature:\n\npredicate(problem, algorithm, state; kwargs...)::Bool\n\n\n\n\n\n","category":"type"},{"location":"logging/#AlgorithmsInterface.LoggingAction","page":"Logging","title":"AlgorithmsInterface.LoggingAction","text":"LoggingAction\n\nAbstract supertype for defining an action that generates a log record.\n\nMethods\n\nAny concrete subtype should at least implement the following method to handle the logging event:\n\nhandle_message!(action, problem, algorithm, state, args...; kwargs...)\n\n\n\n\n\n","category":"type"},{"location":"logging/#AlgorithmsInterface.algorithm_logger","page":"Logging","title":"AlgorithmsInterface.algorithm_logger","text":"algorithm_logger()::Union{AlgorithmLogger, Nothing}\n\nRetrieve the current logger that is responsible for handling logging events. The current logger is determined by a ScopedValue. Whenever nothing is returned, no logging should happen.\n\nSee also set_global_logging_state! for globally toggling whether logging should happen.\n\n\n\n\n\n","category":"function"},{"location":"logging/#AlgorithmsInterface.emit_message-Tuple{Problem, Algorithm, State, Symbol}","page":"Logging","title":"AlgorithmsInterface.emit_message","text":"emit_message(problem::Problem, algorithm::Algorithm, state::State, context::Symbol; kwargs...) -> nothing\nemit_message(algorithm_logger, problem::Problem, algorithm::Algorithm, state::State, context::Symbol; kwargs...) -> nothing\n\nUse the current or the provided algorithm logger to handle the logging event of the given context. The first signature should be favored as it correctly handles accessing the logger and respecting global toggles for enabling and disabling the logging system.\n\nThe second signature should be used exclusively in (very) hot loops, where the overhead of AlgorithmsInterface.algorithm_logger() is too large. In this case, you can manually extract the algorithm_logger() once outside of the hot loop.\n\n\n\n\n\n","category":"method"},{"location":"logging/#AlgorithmsInterface.get_global_logging_state","page":"Logging","title":"AlgorithmsInterface.get_global_logging_state","text":"get_global_logging_state()\nset_global_logging_state!(state::Bool) -> previous_state\n\nRetrieve or set the value to globally enable or disable the handling of logging events.\n\n\n\n\n\n","category":"function"},{"location":"logging/#AlgorithmsInterface.handle_message!-Tuple{LoggingAction, Problem, Algorithm, State}","page":"Logging","title":"AlgorithmsInterface.handle_message!","text":"handle_message!(action::LoggingAction, problem::Problem, algorithm::Algorithm, state::State; kwargs...)\n\nEntry-point for defining an implementation of how to handle a logging event for a given LoggingAction.\n\n\n\n\n\n","category":"method"},{"location":"logging/#AlgorithmsInterface.set_global_logging_state!","page":"Logging","title":"AlgorithmsInterface.set_global_logging_state!","text":"get_global_logging_state()\nset_global_logging_state!(state::Bool) -> previous_state\n\nRetrieve or set the value to globally enable or disable the handling of logging events.\n\n\n\n\n\n","category":"function"},{"location":"logging/#AlgorithmsInterface.with_algorithmlogger-Tuple{Any, Vararg{Any}}","page":"Logging","title":"AlgorithmsInterface.with_algorithmlogger","text":"with_algorithmlogger(f, (context => action)::Pair{Symbol, LoggingAction}...)\nwith_algorithmlogger((context => action)::Pair{Symbol, LoggingAction}...) do\n    # insert arbitrary code here\nend\n\nRun the given zero-argument function f() while mapping events of given contexts to their respective actions. By default, the following events trigger a logging action with the given context:\n\ncontext event\n:Start The solver will start.\n:PreStep The solver is about to take a step.\n:PostStep The solver has taken a step.\n:Stop The solver has finished.\n\nHowever, further events and actions can be emitted through the emit_message interface.\n\nSee also the scoped value AlgorithmsInterface.algorithm_logger.\n\n\n\n\n\n","category":"method"},{"location":"#AlgorithmsInterface.jl","page":"Home","title":"AlgorithmsInterface.jl","text":"Welcome to the Documentation of AlgorithmsInterface.jl.","category":"section"},{"location":"#AlgorithmsInterface.AlgorithmsInterface","page":"Home","title":"AlgorithmsInterface.AlgorithmsInterface","text":"🧮 AlgorithmsInterface.jl: an interface for iterative algorithms in Julia\n\n📚 Documentation: juliamanifolds.github.io/AlgorithmsInterface.jl/\n📦 Repository: github.com/JuliaManifolds/AlgorithmsInterface.jl\n💬 Discussions: github.com/JuliaManifolds/AlgorithmsInterface.jl/discussions\n🎯 Issues: github.com/JuliaManifolds/AlgorithmsInterface.jl/issues\n\n\n\n\n\n","category":"module"},{"location":"notation/#Notation","page":"Notation","title":"Notation","text":"Throughout the package we use the following abbreviations and variable names, where the longer names are usually used in the documentation and as keywords. The shorter ones are often used in code when their name does not cause ambiguities.\n\nName Variable Comment\nAlgorithm algorithm, a \nProblem problem, p \nState state, s \nStoppingCriterion stopping_criterion, sc \nStoppingCriterionState stopping_criterion_state, scs ","category":"section"}]
}
