<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interface · AlgorithmsInterface.jl</title><meta name="title" content="Interface · AlgorithmsInterface.jl"/><meta property="og:title" content="Interface · AlgorithmsInterface.jl"/><meta property="twitter:title" content="Interface · AlgorithmsInterface.jl"/><meta name="description" content="Documentation for AlgorithmsInterface.jl."/><meta property="og:description" content="Documentation for AlgorithmsInterface.jl."/><meta property="twitter:description" content="Documentation for AlgorithmsInterface.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="AlgorithmsInterface.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">AlgorithmsInterface.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Interface</a><ul class="internal"><li><a class="tocitem" href="#sec_heron"><span>Concrete example: Heron&#39;s method</span></a></li><li><a class="tocitem" href="#Reference:-Core-interface-types-and-functions"><span>Reference: Core interface types &amp; functions</span></a></li></ul></li><li><a class="tocitem" href="../stopping_criterion/">Stopping criteria</a></li><li><a class="tocitem" href="../logging/">Logging</a></li><li><a class="tocitem" href="../notation/">Notation</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/main/docs/src/interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="sec_interface"><a class="docs-heading-anchor" href="#sec_interface">The algorithm interface</a><a id="sec_interface-1"></a><a class="docs-heading-anchor-permalink" href="#sec_interface" title="Permalink"></a></h1><p>This section starts a single, cohesive story that will weave through all documentation pages. We will incrementally build an iterative algorithm, enrich it with stopping criteria, and finally refine how it records (logs) its progress. Instead of presenting the API in the abstract, we anchor every concept in one concrete, tiny example you can copy &amp; adapt.</p><p>Why an “interface” for algorithms? Iterative numerical methods nearly always share the same moving pieces:</p><ul><li>immutable input (the mathematical problem you are solving),</li><li>immutable configuration (parameters and knobs of the chosen algorithm), and</li><li>mutable working data (current iterate, caches, diagnostics) that evolves as you step.</li></ul><p>Bundling these together loosely without forcing one giant monolithic type makes it easier to:</p><ul><li>reason about what is allowed to change and what must remain fixed,</li><li>write generic tooling (e.g. stopping logic, logging, benchmarking) that applies across many algorithms,</li><li>test algorithms in isolation by constructing minimal <code>Problem</code>/<code>Algorithm</code> pairs, and</li><li>extend behavior (add new stopping criteria, new logging events) without rewriting core loops.</li></ul><p>The interface in this package formalizes those roles with three abstract types:</p><ul><li><a href="#Problem"><code>Problem</code></a>: immutable, algorithm‑agnostic input data.</li><li><a href="#Algorithm"><code>Algorithm</code></a>: immutable configuration and parameters deciding how to iterate.</li><li><a href="#State"><code>State</code></a>: mutable data that evolves (current iterate, caches, counters, diagnostics).</li></ul><p>It provides a framework for decomposing iterative methods into small, composable parts: concrete <code>Problem</code>/<code>Algorithm</code>/<code>State</code> types have to implement a minimal set of core functionality, and this package helps to stitch everything together and provide additional helper functionality such as stopping criteria and logging functionality.</p><h2 id="sec_heron"><a class="docs-heading-anchor" href="#sec_heron">Concrete example: Heron&#39;s method</a><a id="sec_heron-1"></a><a class="docs-heading-anchor-permalink" href="#sec_heron" title="Permalink"></a></h2><p>To make everything tangible, we will work through a concrete example to illustrate the library&#39;s goals and concepts. Our running example is Heron&#39;s / Babylonian method for estimating <span>$\sqrt{S}$</span>. (see also the concise background on Wikipedia: <a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method">Babylonian method (Heron&#39;s method)</a>): Starting from an initial guess <span>$x_0$</span>, we may converge to the solution by iterating:</p><p class="math-container">\[x_{k+1} = \frac{1}{2}\left(x_k + \frac{S}{x_k}\right)\]</p><p>We therefore suggest the following concrete implementations of the abstract types provided by this package: They are illustrative; various performance and generality questions will be left unaddressed to keep this example simple.</p><h3 id="Algorithm-types"><a class="docs-heading-anchor" href="#Algorithm-types">Algorithm types</a><a id="Algorithm-types-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-types" title="Permalink"></a></h3><pre><code class="language-julia hljs">using AlgorithmsInterface

struct SqrtProblem &lt;: Problem
    S::Float64                # number whose square root we seek
end

struct HeronAlgorithm &lt;: Algorithm
    stopping_criterion        # will be plugged in later (any StoppingCriterion)
end

mutable struct HeronState &lt;: State
    iterate::Float64          # current iterate
    iteration::Int            # current iteration count
    stopping_criterion_state  # will be plugged in later (any StoppingCriterionState)
end</code></pre><h3 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h3><p>In order to begin implementing the core parts of our algorithm, we start at the very beginning. There are two main entry points provided by the interface:</p><ul><li><a href="#AlgorithmsInterface.initialize_state-Tuple{Problem, Algorithm}"><code>initialize_state</code></a> constructs an entirely new state for the algorithm</li><li><a href="#AlgorithmsInterface.initialize_state!-Tuple{Problem, Algorithm, State}"><code>initialize_state!</code></a> (in-place) reset of an existing state.</li></ul><p>An example implementation might look like:</p><pre><code class="language-julia hljs">function AlgorithmsInterface.initialize_state(
        problem::SqrtProblem, algorithm::HeronAlgorithm,
        stopping_criterion_state::StoppingCriterionState;
        kwargs...
    )
    x0 = rand()
    iteration = 0
    return HeronState(x0, 0, stopping_criterion_state)
end

function AlgorithmsInterface.initialize_state!(
        problem::SqrtProblem, algorithm::HeronAlgorithm, state::HeronState;
        kwargs...
    )
    state.iteration = 0
    return state
end</code></pre><h3 id="Iteration-steps"><a class="docs-heading-anchor" href="#Iteration-steps">Iteration steps</a><a id="Iteration-steps-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration-steps" title="Permalink"></a></h3><p>Algorithms define a mutable step via <a href="#AlgorithmsInterface.step!-Tuple{Problem, Algorithm, State}"><code>step!</code></a>. For Heron&#39;s method:</p><pre><code class="language-julia hljs">function AlgorithmsInterface.step!(problem::SqrtProblem, algorithm::HeronAlgorithm, state::HeronState)
    S = problem.S
    x = state.iterate
    state.iterate = 0.5 * (x + S / x)
    return state
end</code></pre><p>Note that we are only focussing on the actual algorithm, and <em>not</em> incrementing the iteration counter. These kinds of bookkeeping should be handled by the <a href="#AlgorithmsInterface.increment!-Tuple{State}"><code>AlgorithmsInterface.increment!</code></a> function, which will by default already increment the iteration counter. The following generic functionality is therefore enough for our purposes, and does <em>not</em> need to be defined. Nevertheless, if additional bookkeeping would be desired, this can be achieved by overloading that function:</p><pre><code class="language-julia hljs">function AlgorithmsInterface.increment!(state::State)
    state.iteration += 1
    return state
end</code></pre><h3 id="Running-the-algorithm"><a class="docs-heading-anchor" href="#Running-the-algorithm">Running the algorithm</a><a id="Running-the-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-algorithm" title="Permalink"></a></h3><p>With these definitions in place you can already run (assuming you also choose a stopping criterion – added in the next section):</p><pre><code class="language-julia hljs">function heron_sqrt(x; maxiter = 10)
    prob = SqrtProblem(x)
    alg  = HeronAlgorithm(StopAfterIteration(maxiter))
    state = solve(prob, alg)  # allocates &amp; runs
    return state.iterate
end

println(&quot;Approximate sqrt: &quot;, heron_sqrt(16.0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Approximate sqrt: 4.0</code></pre><p>We will refine this example with better halting logic and logging shortly.</p><h2 id="Reference:-Core-interface-types-and-functions"><a class="docs-heading-anchor" href="#Reference:-Core-interface-types-and-functions">Reference: Core interface types &amp; functions</a><a id="Reference:-Core-interface-types-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Reference:-Core-interface-types-and-functions" title="Permalink"></a></h2><p>Below are the automatic API docs for the core interface pieces. Read them after grasping the example above – the intent should now be clearer.</p><article><details class="docstring"><summary id="AlgorithmsInterface.initialize_state!-Tuple{Problem, Algorithm, State}"><a class="docstring-binding" href="#AlgorithmsInterface.initialize_state!-Tuple{Problem, Algorithm, State}"><code>AlgorithmsInterface.initialize_state!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">state = initialize_state(
    problem::Problem, algorithm::Algorithm,
    [stopping_criterion_state::StoppingCriterionState];
    kwargs...
)
state = initialize_state!(
    problem::Problem, algorithm::Algorithm, state::State;
    kwargs...
)</code></pre><p>Initialize a <a href="#State"><code>State</code></a> based on a <a href="#Problem"><code>Problem</code></a> and an <a href="#Algorithm"><code>Algorithm</code></a>. The <code>kwargs...</code> should allow to initialize for example the initial point. This can be done in-place for <code>state</code>, then only values that did change have to be provided.</p><p>Note that since the returned state should also hold <code>state.stopping_criterion_state</code>, which will be used to keep the internal state of the stopping criterion, the out-of-place version receives this as one of its arguments. By default, that will be initialized separately through a call to <a href="#AlgorithmsInterface.initialize_stopping_state-Tuple{Problem, Algorithm, StoppingCriterion}"><code>initialize_stopping_state</code></a> and provided as an argument.</p><p>On the other hand, the in-place version is not responsible for initializing the <code>stopping_criterion_state</code>, as that will be handled separately by <a href="#AlgorithmsInterface.initialize_stopping_state!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>initialize_stopping_state!</code></a>.</p><p>Users that which to handle the stopping criterion initialization in <code>initialize_state</code> manually should overload the 2-argument version, while by default the 3-argument version should be implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/interface.jl#L38-L63">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.initialize_state-Tuple{Problem, Algorithm}"><a class="docstring-binding" href="#AlgorithmsInterface.initialize_state-Tuple{Problem, Algorithm}"><code>AlgorithmsInterface.initialize_state</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">state = initialize_state(
    problem::Problem, algorithm::Algorithm,
    [stopping_criterion_state::StoppingCriterionState];
    kwargs...
)
state = initialize_state!(
    problem::Problem, algorithm::Algorithm, state::State;
    kwargs...
)</code></pre><p>Initialize a <a href="#State"><code>State</code></a> based on a <a href="#Problem"><code>Problem</code></a> and an <a href="#Algorithm"><code>Algorithm</code></a>. The <code>kwargs...</code> should allow to initialize for example the initial point. This can be done in-place for <code>state</code>, then only values that did change have to be provided.</p><p>Note that since the returned state should also hold <code>state.stopping_criterion_state</code>, which will be used to keep the internal state of the stopping criterion, the out-of-place version receives this as one of its arguments. By default, that will be initialized separately through a call to <a href="#AlgorithmsInterface.initialize_stopping_state-Tuple{Problem, Algorithm, StoppingCriterion}"><code>initialize_stopping_state</code></a> and provided as an argument.</p><p>On the other hand, the in-place version is not responsible for initializing the <code>stopping_criterion_state</code>, as that will be handled separately by <a href="#AlgorithmsInterface.initialize_stopping_state!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>initialize_stopping_state!</code></a>.</p><p>Users that which to handle the stopping criterion initialization in <code>initialize_state</code> manually should overload the 2-argument version, while by default the 3-argument version should be implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/interface.jl#L33-L58">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.solve!-Tuple{Problem, Algorithm, State}"><a class="docstring-binding" href="#AlgorithmsInterface.solve!-Tuple{Problem, Algorithm, State}"><code>AlgorithmsInterface.solve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve!(problem::Problem, algorithm::Algorithm, state::State; kwargs...)</code></pre><p>Solve the <a href="#Problem"><code>Problem</code></a> using an <a href="#Algorithm"><code>Algorithm</code></a>, starting from a given <a href="#State"><code>State</code></a>. The state is modified in-place.</p><p>All keyword arguments are passed to the <a href="#AlgorithmsInterface.initialize_state!-Tuple{Problem, Algorithm, State}"><code>initialize_state!</code></a> and <a href="#AlgorithmsInterface.initialize_stopping_state!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>initialize_stopping_state!</code></a> functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/interface.jl#L59-L67">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.solve-Tuple{Problem, Algorithm}"><a class="docstring-binding" href="#AlgorithmsInterface.solve-Tuple{Problem, Algorithm}"><code>AlgorithmsInterface.solve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve(problem::Problem, algorithm::Algorithm; kwargs...)</code></pre><p>Solve the <a href="#Problem"><code>Problem</code></a> using an <a href="#Algorithm"><code>Algorithm</code></a>.</p><p>The keyword arguments <code>kwargs...</code> have to provide enough details such that the corresponding state and stopping state initialisation <a href="#AlgorithmsInterface.initialize_state-Tuple{Problem, Algorithm}"><code>initialize_state</code></a><code>and [</code>initialize<em>stopping</em>state`](@ref) can be used to return valid states and stopping states.</p><p>By default this method continues to call <a href="#AlgorithmsInterface.solve!-Tuple{Problem, Algorithm, State}"><code>solve!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/interface.jl#L43-L53">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.step!-Tuple{Problem, Algorithm, State}"><a class="docstring-binding" href="#AlgorithmsInterface.step!-Tuple{Problem, Algorithm, State}"><code>AlgorithmsInterface.step!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">step!(problem::Problem, algorithm::Algorithm, state::State)</code></pre><p>Perform the current step of an <a href="#Algorithm"><code>Algorithm</code></a> solving a <a href="#Problem"><code>Problem</code></a> modifying the algorithm&#39;s <a href="#State"><code>State</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/interface.jl#L100-L105">source</a></section></details></article><h3 id="Algorithm"><a class="docs-heading-anchor" href="#Algorithm">Algorithm</a><a id="Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm" title="Permalink"></a></h3><article><details class="docstring"><summary id="AlgorithmsInterface.Algorithm"><a class="docstring-binding" href="#AlgorithmsInterface.Algorithm"><code>AlgorithmsInterface.Algorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Algorithm</code></pre><p>An abstract type to represent an algorithm.</p><p>A concrete algorithm contains all static parameters that characterise the algorithms. Together with a <a href="#Problem"><code>Problem</code></a> an <code>Algorithm</code> subtype should be able to initialize or reset a <a href="#State"><code>State</code></a>.</p><p><strong>Properties</strong></p><p>Algorithms can contain any number of properties that are needed to define the algorithm, but should additionally contain the following properties to interact with the stopping criteria.</p><ul><li><code>stopping_criterion::StoppingCriterion</code></li></ul><p><strong>Example</strong></p><p>For a <a href="https://en.wikipedia.org/wiki/Gradient_descent">gradient descent</a> algorithm the algorithm would specify which step size selection to use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/algorithm.jl#L1-L21">source</a></section></details></article><h3 id="Problem"><a class="docs-heading-anchor" href="#Problem">Problem</a><a id="Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Problem" title="Permalink"></a></h3><article><details class="docstring"><summary id="AlgorithmsInterface.Problem"><a class="docstring-binding" href="#AlgorithmsInterface.Problem"><code>AlgorithmsInterface.Problem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Problem</code></pre><p>An abstract type to represent a problem to be solved with all its static properties, that do not change during an algorithm run.</p><p><strong>Example</strong></p><p>For a <a href="https://en.wikipedia.org/wiki/Gradient_descent">gradient descent</a> algorithm the problem consists of</p><ul><li>a <code>cost</code> function <span>$f: C → ℝ$</span></li><li>a gradient function <span>$\operatorname{grad}f$</span></li></ul><p>The problem then could that these are given in four different forms</p><ul><li>a function <code>c = cost(x)</code> and a gradient <code>d = gradient(x)</code></li><li>a function <code>c = cost(x)</code> and an in-place gradient <code>gradient!(d,x)</code></li><li>a combined cost-grad function <code>(c,d) = costgrad(x)</code></li><li>a combined cost-grad function <code>(c, d) = costgrad!(d, x)</code> that computes the gradient in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/problem.jl#L1-L20">source</a></section></details></article><h3 id="State"><a class="docs-heading-anchor" href="#State">State</a><a id="State-1"></a><a class="docs-heading-anchor-permalink" href="#State" title="Permalink"></a></h3><article><details class="docstring"><summary id="AlgorithmsInterface.State"><a class="docstring-binding" href="#AlgorithmsInterface.State"><code>AlgorithmsInterface.State</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">State</code></pre><p>An abstract type to represent the state an iterative algorithm is in.</p><p>The state consists of any information that describes the current step the algorithm is in and keeps all information needed from one step to the next.</p><p><strong>Properties</strong></p><p>In order to interact with the stopping criteria, the state should contain the following properties, and provide corresponding <code>getproperty</code> and <code>setproperty!</code> methods.</p><ul><li><code>iteration</code> – the current iteration step <span>$k$</span> that is is currently performed or was last performed</li><li><code>stopping_criterion_state</code> – a <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> that indicates whether an <a href="#Algorithm"><code>Algorithm</code></a> will stop after this iteration or has stopped.</li><li><code>iterate</code> the current iterate <span>$x^{(k)}$</span>.</li></ul><p><strong>Methods</strong></p><p>The following methods should be implemented for a state</p><ul><li><a href="#AlgorithmsInterface.increment!-Tuple{State}"><code>increment!</code></a>(state)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/state.jl#L1-L24">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.increment!-Tuple{State}"><a class="docstring-binding" href="#AlgorithmsInterface.increment!-Tuple{State}"><code>AlgorithmsInterface.increment!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">increment!(state::State)</code></pre><p>Increment the current iteration a <a href="#State"><code>State</code></a> either is currently performing or was last performed</p><p>The default assumes that the current iteration is stored in <code>state.iteration</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/state.jl#L27-L33">source</a></section></details></article><h3 id="Stopping-Criteria"><a class="docs-heading-anchor" href="#Stopping-Criteria">Stopping Criteria</a><a id="Stopping-Criteria-1"></a><a class="docs-heading-anchor-permalink" href="#Stopping-Criteria" title="Permalink"></a></h3><article><details class="docstring"><summary id="AlgorithmsInterface.StoppingCriterion"><a class="docstring-binding" href="#AlgorithmsInterface.StoppingCriterion"><code>AlgorithmsInterface.StoppingCriterion</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StoppingCriterion</code></pre><p>An abstract type to represent a stopping criterion of an <a href="#Algorithm"><code>Algorithm</code></a>.</p><p>A concrete <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> should also implement a <a href="#AlgorithmsInterface.initialize_state-Tuple{Problem, Algorithm}"><code>initialize_state(problem::Problem, algorithm::Algorithm, stopping_criterion::StoppingCriterion; kwargs...)</code></a> function to create its accompanying <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a>. as well as the corresponding mutating variant to reset such a <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a>.</p><p>It should usually implement</p><ul><li><a href="#AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion, StoppingCriterionState}"><code>indicates_convergence</code></a><code>(stopping_criterion)</code></li><li><a href="#AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion, StoppingCriterionState}"><code>indicates_convergence</code></a><code>(stopping_criterion, stopping_criterion_state)</code></li><li><a href="#AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>is_finished!</code></a><code>(problem, algorithm, state, stopping_criterion, stopping_criterion_state)</code></li><li><a href="#AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>is_finished</code></a><code>(problem, algorithm, state, stopping_criterion, stopping_criterion_state)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/stopping.jl#L1-L17">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.StoppingCriterionState"><a class="docstring-binding" href="#AlgorithmsInterface.StoppingCriterionState"><code>AlgorithmsInterface.StoppingCriterionState</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StoppingCriterionState</code></pre><p>An abstract type to represent a stopping criterion state within a <a href="#State"><code>State</code></a>. It represents the concrete state a <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> is in.</p><p>It should usually implement</p><ul><li><a href="#AlgorithmsInterface.get_reason-Tuple{StoppingCriterion, StoppingCriterionState}"><code>get_reason</code></a><code>(stopping_criterion, stopping_criterion_state)</code></li><li><a href="#AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion, StoppingCriterionState}"><code>indicates_convergence</code></a><code>(stopping_criterion, stopping_criterion_state)</code></li><li><a href="#AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>is_finished!</code></a><code>(problem, algorithm, state, stopping_criterion, stopping_criterion_state)</code></li><li><a href="#AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>is_finished</code></a><code>(problem, algorithm, state, stopping_criterion, stopping_criterion_state)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/stopping.jl#L20-L32">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.get_reason-Tuple{StoppingCriterion, StoppingCriterionState}"><a class="docstring-binding" href="#AlgorithmsInterface.get_reason-Tuple{StoppingCriterion, StoppingCriterionState}"><code>AlgorithmsInterface.get_reason</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_reason(stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)</code></pre><p>Provide a reason in human readable text as to why a <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> with <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> indicated to stop. If it does not indicate to stop, this should return <code>nothing</code>.</p><p>Providing the iteration at which this indicated to stop in the reason would be preferable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/stopping.jl#L78-L85">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion, StoppingCriterionState}"><a class="docstring-binding" href="#AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion, StoppingCriterionState}"><code>AlgorithmsInterface.indicates_convergence</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">indicates_convergence(stopping_criterion::StoppingCriterion, ::StoppingCriterionState)</code></pre><p>Return whether or not a <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> indicates convergence when it is in <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a>.</p><p>By default this checks whether the <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> has actually stopped. If so it returns whether <code>stopping_criterion</code> itself indicates convergence, otherwise it returns <code>false</code>, since the algorithm has then not yet stopped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/stopping.jl#L96-L104">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion}"><a class="docstring-binding" href="#AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion}"><code>AlgorithmsInterface.indicates_convergence</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">indicates_convergence(stopping_criterion::StoppingCriterion)</code></pre><p>Return whether or not a <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> indicates convergence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/stopping.jl#L89-L93">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.initialize_stopping_state!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><a class="docstring-binding" href="#AlgorithmsInterface.initialize_stopping_state!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>AlgorithmsInterface.initialize_stopping_state!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">stopping_criterion_state = initialize_stopping_state(
    problem::Problem, algorithm::Algorithm
    stopping_criterion::StoppingCriterion = algorithm.stopping_criterion;
    kwargs...
)
stopping_criterion_state = initialize_stopping_state!(
    problem::Problem, algorithm::Algorithm, state::State,
    stopping_criterion::StoppingCriterion = algorithm.stopping_criterion,
    stopping_criterion_state::StoppingCriterionState = state.stopping_criterion_state;
    kwargs...
)</code></pre><p>Initialize a <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> based on a <a href="#Problem"><code>Problem</code></a>, <a href="#Algorithm"><code>Algorithm</code></a>, <a href="#State"><code>State</code></a> triplet for a given <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a>. By default, the <code>stopping_criterion</code> is retrieved from the <code>Algorithm</code> via <code>algorithm.stopping_criterion</code>.</p><p>The first signature is used for setting up a completely new stopping criterion state, while the second simply resets a given state in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/stopping.jl#L70-L89">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.initialize_stopping_state-Tuple{Problem, Algorithm, StoppingCriterion}"><a class="docstring-binding" href="#AlgorithmsInterface.initialize_stopping_state-Tuple{Problem, Algorithm, StoppingCriterion}"><code>AlgorithmsInterface.initialize_stopping_state</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">stopping_criterion_state = initialize_stopping_state(
    problem::Problem, algorithm::Algorithm
    stopping_criterion::StoppingCriterion = algorithm.stopping_criterion;
    kwargs...
)
stopping_criterion_state = initialize_stopping_state!(
    problem::Problem, algorithm::Algorithm, state::State,
    stopping_criterion::StoppingCriterion = algorithm.stopping_criterion,
    stopping_criterion_state::StoppingCriterionState = state.stopping_criterion_state;
    kwargs...
)</code></pre><p>Initialize a <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> based on a <a href="#Problem"><code>Problem</code></a>, <a href="#Algorithm"><code>Algorithm</code></a>, <a href="#State"><code>State</code></a> triplet for a given <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a>. By default, the <code>stopping_criterion</code> is retrieved from the <code>Algorithm</code> via <code>algorithm.stopping_criterion</code>.</p><p>The first signature is used for setting up a completely new stopping criterion state, while the second simply resets a given state in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/stopping.jl#L61-L80">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><a class="docstring-binding" href="#AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>AlgorithmsInterface.is_finished!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_finished(problem::Problem, algorithm::Algorithm, state::State)
is_finished(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)
is_finished!(problem::Problem, algorithm::Algorithm, state::State)
is_finished!(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)</code></pre><p>Indicate whether an <a href="#Algorithm"><code>Algorithm</code></a> solving <a href="#Problem"><code>Problem</code></a> is finished having reached a certain <a href="#State"><code>State</code></a>. The variant with three arguments by default extracts the <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> and its <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> and their actual checks are performed in the implementation with five arguments.</p><p>The mutating variant does alter the <code>stopping_criterion_state</code> and and should only be called once per iteration, the other one merely inspects the current status without mutation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/stopping.jl#L151-L164">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State}"><a class="docstring-binding" href="#AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State}"><code>AlgorithmsInterface.is_finished!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_finished(problem::Problem, algorithm::Algorithm, state::State)
is_finished(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)
is_finished!(problem::Problem, algorithm::Algorithm, state::State)
is_finished!(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)</code></pre><p>Indicate whether an <a href="#Algorithm"><code>Algorithm</code></a> solving <a href="#Problem"><code>Problem</code></a> is finished having reached a certain <a href="#State"><code>State</code></a>. The variant with three arguments by default extracts the <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> and its <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> and their actual checks are performed in the implementation with five arguments.</p><p>The mutating variant does alter the <code>stopping_criterion_state</code> and and should only be called once per iteration, the other one merely inspects the current status without mutation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/stopping.jl#L142-L155">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><a class="docstring-binding" href="#AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>AlgorithmsInterface.is_finished</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_finished(problem::Problem, algorithm::Algorithm, state::State)
is_finished(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)
is_finished!(problem::Problem, algorithm::Algorithm, state::State)
is_finished!(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)</code></pre><p>Indicate whether an <a href="#Algorithm"><code>Algorithm</code></a> solving <a href="#Problem"><code>Problem</code></a> is finished having reached a certain <a href="#State"><code>State</code></a>. The variant with three arguments by default extracts the <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> and its <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> and their actual checks are performed in the implementation with five arguments.</p><p>The mutating variant does alter the <code>stopping_criterion_state</code> and and should only be called once per iteration, the other one merely inspects the current status without mutation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/stopping.jl#L139-L152">source</a></section></details></article><article><details class="docstring"><summary id="AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State}"><a class="docstring-binding" href="#AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State}"><code>AlgorithmsInterface.is_finished</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_finished(problem::Problem, algorithm::Algorithm, state::State)
is_finished(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)
is_finished!(problem::Problem, algorithm::Algorithm, state::State)
is_finished!(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)</code></pre><p>Indicate whether an <a href="#Algorithm"><code>Algorithm</code></a> solving <a href="#Problem"><code>Problem</code></a> is finished having reached a certain <a href="#State"><code>State</code></a>. The variant with three arguments by default extracts the <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> and its <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> and their actual checks are performed in the implementation with five arguments.</p><p>The mutating variant does alter the <code>stopping_criterion_state</code> and and should only be called once per iteration, the other one merely inspects the current status without mutation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/stopping.jl#L130-L143">source</a></section></details></article><article><details class="docstring"><summary id="Base.summary-Tuple{IO, StoppingCriterion, StoppingCriterionState}"><a class="docstring-binding" href="#Base.summary-Tuple{IO, StoppingCriterion, StoppingCriterionState}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">summary(io::IO, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)</code></pre><p>Provide a summary of the status of a stopping criterion – its parameters and whether it currently indicates to stop. It should not be longer than one line</p><p><strong>Example</strong></p><p>For the <a href="../stopping_criterion/#AlgorithmsInterface.StopAfterIteration"><code>StopAfterIteration</code></a> criterion, the summary looks like</p><pre><code class="nohighlight hljs">Max Iterations (15): not reached</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/6930dabf1a27bc097a91d3e90ae8dbf24be8dbb0/src/interface/stopping.jl#L154-L167">source</a></section></details></article><h3 id="Next:-Stopping-criteria"><a class="docs-heading-anchor" href="#Next:-Stopping-criteria">Next: Stopping criteria</a><a id="Next:-Stopping-criteria-1"></a><a class="docs-heading-anchor-permalink" href="#Next:-Stopping-criteria" title="Permalink"></a></h3><p>Proceed to the stopping criteria section to add robust halting logic (iteration caps, time limits, tolerance on successive iterates, and combinations) to this square‑root example.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../stopping_criterion/">Stopping criteria »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 18 December 2025 01:27">Thursday 18 December 2025</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
