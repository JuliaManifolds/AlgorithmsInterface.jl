<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interface · AlgorithmsInterface.jl</title><meta name="title" content="Interface · AlgorithmsInterface.jl"/><meta property="og:title" content="Interface · AlgorithmsInterface.jl"/><meta property="twitter:title" content="Interface · AlgorithmsInterface.jl"/><meta name="description" content="Documentation for AlgorithmsInterface.jl."/><meta property="og:description" content="Documentation for AlgorithmsInterface.jl."/><meta property="twitter:description" content="Documentation for AlgorithmsInterface.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="AlgorithmsInterface.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">AlgorithmsInterface.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Interface</a><ul class="internal"><li><a class="tocitem" href="#sec_heron"><span>Concrete example: Heron&#39;s method</span></a></li><li><a class="tocitem" href="#Reference:-Core-interface-types-and-functions"><span>Reference: Core interface types &amp; functions</span></a></li></ul></li><li><a class="tocitem" href="../stopping_criterion/">Stopping criteria</a></li><li><a class="tocitem" href="../logging/">Logging</a></li><li><a class="tocitem" href="../notation/">Notation</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/main/docs/src/interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="sec_interface"><a class="docs-heading-anchor" href="#sec_interface">The algorithm interface</a><a id="sec_interface-1"></a><a class="docs-heading-anchor-permalink" href="#sec_interface" title="Permalink"></a></h1><p>This section starts a single, cohesive story that will weave through all documentation pages. We will incrementally build an iterative algorithm, enrich it with stopping criteria, and finally refine how it records (logs) its progress. Instead of presenting the API in the abstract, we anchor every concept in one concrete, tiny example you can copy &amp; adapt.</p><p>Why an “interface” for algorithms? Iterative numerical methods nearly always share the same moving pieces:</p><ul><li>immutable input (the mathematical problem you are solving),</li><li>immutable configuration (parameters and knobs of the chosen algorithm), and</li><li>mutable working data (current iterate, caches, diagnostics) that evolves as you step.</li></ul><p>Bundling these together loosely without forcing one giant monolithic type makes it easier to:</p><ul><li>reason about what is allowed to change and what must remain fixed,</li><li>write generic tooling (e.g. stopping logic, logging, benchmarking) that applies across many algorithms,</li><li>test algorithms in isolation by constructing minimal <code>Problem</code>/<code>Algorithm</code> pairs, and</li><li>extend behavior (add new stopping criteria, new logging events) without rewriting core loops.</li></ul><p>The interface in this package formalizes those roles with three abstract types:</p><ul><li><a href="#Problem"><code>Problem</code></a>: immutable, algorithm‑agnostic input data.</li><li><a href="#Algorithm"><code>Algorithm</code></a>: immutable configuration and parameters deciding how to iterate.</li><li><a href="#State"><code>State</code></a>: mutable data that evolves (current iterate, caches, counters, diagnostics).</li></ul><p>It provides a framework for decomposing iterative methods into small, composable parts: concrete <code>Problem</code>/<code>Algorithm</code>/<code>State</code> types have to implement a minimal set of core functionality, and this package helps to stitch everything together and provide additional helper functionality such as stopping criteria and logging functionality.</p><h2 id="sec_heron"><a class="docs-heading-anchor" href="#sec_heron">Concrete example: Heron&#39;s method</a><a id="sec_heron-1"></a><a class="docs-heading-anchor-permalink" href="#sec_heron" title="Permalink"></a></h2><p>To make everything tangible, we will work through a concrete example to illustrate the library&#39;s goals and concepts. Our running example is Heron&#39;s / Babylonian method for estimating <span>$\sqrt{S}$</span>. (see also the concise background on Wikipedia: <a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method">Babylonian method (Heron&#39;s method)</a>): Starting from an initial guess <span>$x_0$</span>, we may converge to the solution by iterating:</p><p class="math-container">\[x_{k+1} = \frac{1}{2}\left(x_k + \frac{S}{x_k}\right)\]</p><p>We therefore suggest the following concrete implementations of the abstract types provided by this package: They are illustrative; various performance and generality questions will be left unaddressed to keep this example simple.</p><h3 id="Algorithm-types"><a class="docs-heading-anchor" href="#Algorithm-types">Algorithm types</a><a id="Algorithm-types-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-types" title="Permalink"></a></h3><pre><code class="language-julia hljs">using AlgorithmsInterface

struct SqrtProblem &lt;: Problem
    S::Float64                # number whose square root we seek
end

struct HeronAlgorithm &lt;: Algorithm
    stopping_criterion        # will be plugged in later (any StoppingCriterion)
end

mutable struct HeronState &lt;: State
    iterate::Float64          # current iterate
    iteration::Int            # current iteration count
    stopping_criterion_state  # will be plugged in later (any StoppingCriterionState)
end</code></pre><h3 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h3><p>In order to start implementing the core parts of our algorithm, we start at the very beginning. There are two main entry points provided by the interface:</p><ul><li><a href="#AlgorithmsInterface.initialize_state-Tuple{Problem, Algorithm}"><code>initialize_state</code></a> constructs an entirely new state for the algorithm</li><li><a href="#AlgorithmsInterface.initialize_state!-Tuple{Problem, Algorithm, State}"><code>initialize_state!</code></a> (in-place) reset of an existing state.</li></ul><p>An example implementation might look like:</p><pre><code class="language-julia hljs">function AlgorithmsInterface.initialize_state(problem::SqrtProblem, algorithm::HeronAlgorithm; kwargs...)
    x0 = rand() # random initial guess
    stopping_criterion_state = initialize_state(problem, algorithm, algorithm.stopping_criterion)
    return HeronState(x0, 0, stopping_criterion_state)
end

function AlgorithmsInterface.initialize_state!(problem::SqrtProblem, algorithm::HeronAlgorithm, state::HeronState; kwargs...)
    # reset the state for the algorithm
    state.iterate = rand()
    state.iteration = 0

    # reset the state for the stopping criterion
    state = AlgorithmsInterface.initialize_state!(
        problem, algorithm, algorithm.stopping_criterion, state.stopping_criterion_state
    )
    return state
end</code></pre><h3 id="Iteration-steps"><a class="docs-heading-anchor" href="#Iteration-steps">Iteration steps</a><a id="Iteration-steps-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration-steps" title="Permalink"></a></h3><p>Algorithms define a mutable step via <a href="#AlgorithmsInterface.step!-Tuple{Problem, Algorithm, State}"><code>step!</code></a>. For Heron&#39;s method:</p><pre><code class="language-julia hljs">function AlgorithmsInterface.step!(problem::SqrtProblem, algorithm::HeronAlgorithm, state::HeronState)
    S = problem.S
    x = state.iterate
    state.iterate = 0.5 * (x + S / x)
    return state
end</code></pre><p>Note that we are only focussing on the actual algorithm, and <em>not</em> incrementing the iteration counter. These kinds of bookkeeping should be handled by the <a href="#AlgorithmsInterface.increment!-Tuple{State}"><code>AlgorithmsInterface.increment!</code></a> function, which will by default already increment the iteration counter. The following generic functionality is therefore enough for our purposes, and does <em>not</em> need to be defined. Nevertheless, if additional bookkeeping would be desired, this can be achieved by overloading that function:</p><pre><code class="language-julia hljs">function AlgorithmsInterface.increment!(state::State)
    state.iteration += 1
    return state
end</code></pre><h3 id="Running-the-algorithm"><a class="docs-heading-anchor" href="#Running-the-algorithm">Running the algorithm</a><a id="Running-the-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-algorithm" title="Permalink"></a></h3><p>With these definitions in place you can already run (assuming you also choose a stopping criterion – added in the next section):</p><pre><code class="language-julia hljs">function heron_sqrt(x; maxiter = 10)
    prob = SqrtProblem(x)
    alg  = HeronAlgorithm(StopAfterIteration(maxiter))
    state = solve(prob, alg)  # allocates &amp; runs
    return state.iterate
end

println(&quot;Approximate sqrt: &quot;, heron_sqrt(16.0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Approximate sqrt: 4.0</code></pre><p>We will refine this example with better halting logic and logging shortly.</p><h2 id="Reference:-Core-interface-types-and-functions"><a class="docs-heading-anchor" href="#Reference:-Core-interface-types-and-functions">Reference: Core interface types &amp; functions</a><a id="Reference:-Core-interface-types-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Reference:-Core-interface-types-and-functions" title="Permalink"></a></h2><p>Below are the automatic API docs for the core interface pieces. Read them after grasping the example above – the intent should now be clearer.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.initialize_state!-Tuple{Problem, Algorithm, State}" href="#AlgorithmsInterface.initialize_state!-Tuple{Problem, Algorithm, State}"><code>AlgorithmsInterface.initialize_state!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">state = initialize_state(problem::Problem, algorithm::Algorithm; kwargs...)
state = initialize_state!(problem::Problem, algorithm::Algorithm, state::State; kwargs...)</code></pre><p>Initialize a <a href="#State"><code>State</code></a> based on a <a href="#Problem"><code>Problem</code></a> and an <a href="#Algorithm"><code>Algorithm</code></a>. The <code>kwargs...</code> should allow to initialize for example the initial point. This can be done in-place for <code>state</code>, then only values that did change have to be provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/interface/interface.jl#L17-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.initialize_state-Tuple{Problem, Algorithm}" href="#AlgorithmsInterface.initialize_state-Tuple{Problem, Algorithm}"><code>AlgorithmsInterface.initialize_state</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">state = initialize_state(problem::Problem, algorithm::Algorithm; kwargs...)
state = initialize_state!(problem::Problem, algorithm::Algorithm, state::State; kwargs...)</code></pre><p>Initialize a <a href="#State"><code>State</code></a> based on a <a href="#Problem"><code>Problem</code></a> and an <a href="#Algorithm"><code>Algorithm</code></a>. The <code>kwargs...</code> should allow to initialize for example the initial point. This can be done in-place for <code>state</code>, then only values that did change have to be provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/interface/interface.jl#L12-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.solve!-Tuple{Problem, Algorithm, State}" href="#AlgorithmsInterface.solve!-Tuple{Problem, Algorithm, State}"><code>AlgorithmsInterface.solve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(problem::Problem, algorithm::Algorithm, state::State; kwargs...)</code></pre><p>Solve the <a href="#Problem"><code>Problem</code></a> using an <a href="#Algorithm"><code>Algorithm</code></a>, starting from a given <a href="#State"><code>State</code></a>. The state is modified in-place.</p><p>All keyword arguments are passed to the <a href="#AlgorithmsInterface.initialize_state!-Tuple{Problem, Algorithm, State}"><code>initialize_state!</code></a><code>(problem, algorithm, state)</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/interface/interface.jl#L37-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.solve-Tuple{Problem, Algorithm}" href="#AlgorithmsInterface.solve-Tuple{Problem, Algorithm}"><code>AlgorithmsInterface.solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve(problem::Problem, algorithm::Algorithm; kwargs...)</code></pre><p>Solve the <a href="#Problem"><code>Problem</code></a> using an <a href="#Algorithm"><code>Algorithm</code></a>. The keyword arguments <code>kwargs...</code> have to provide enough details such that the corresponding state initialisation <a href="#AlgorithmsInterface.initialize_state-Tuple{Problem, Algorithm}"><code>initialize_state</code></a><code>(problem, algorithm)</code> returns a state.</p><p>By default this method continues to call <a href="#AlgorithmsInterface.solve!-Tuple{Problem, Algorithm, State}"><code>solve!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/interface/interface.jl#L22-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.step!-Tuple{Problem, Algorithm, State}" href="#AlgorithmsInterface.step!-Tuple{Problem, Algorithm, State}"><code>AlgorithmsInterface.step!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">step!(problem::Problem, algorithm::Algorithm, state::State)</code></pre><p>Perform the current step of an <a href="#Algorithm"><code>Algorithm</code></a> solving a <a href="#Problem"><code>Problem</code></a> modifying the algorithm&#39;s <a href="#State"><code>State</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/interface/interface.jl#L75-L80">source</a></section></article><h3 id="Algorithm"><a class="docs-heading-anchor" href="#Algorithm">Algorithm</a><a id="Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.Algorithm" href="#AlgorithmsInterface.Algorithm"><code>AlgorithmsInterface.Algorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Algorithm</code></pre><p>An abstract type to represent an algorithm.</p><p>A concrete algorithm contains all static parameters that characterise the algorithms. Together with a <a href="#Problem"><code>Problem</code></a> an <code>Algorithm</code> subtype should be able to initialize or reset a <a href="#State"><code>State</code></a>.</p><p><strong>Properties</strong></p><p>Algorithms can contain any number of properties that are needed to define the algorithm, but should additionally contain the following properties to interact with the stopping criteria.</p><ul><li><code>stopping_criterion::StoppingCriterion</code></li></ul><p><strong>Example</strong></p><p>For a <a href="https://en.wikipedia.org/wiki/Gradient_descent">gradient descent</a> algorithm the algorithm would specify which step size selection to use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/interface/algorithm.jl#L1-L21">source</a></section></article><h3 id="Problem"><a class="docs-heading-anchor" href="#Problem">Problem</a><a id="Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Problem" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.Problem" href="#AlgorithmsInterface.Problem"><code>AlgorithmsInterface.Problem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Problem</code></pre><p>An abstract type to represent a problem to be solved with all its static properties, that do not change during an algorithm run.</p><p><strong>Example</strong></p><p>For a <a href="https://en.wikipedia.org/wiki/Gradient_descent">gradient descent</a> algorithm the problem consists of</p><ul><li>a <code>cost</code> function <span>$f: C → ℝ$</span></li><li>a gradient function <span>$\operatorname{grad}f$</span></li></ul><p>The problem then could that these are given in four different forms</p><ul><li>a function <code>c = cost(x)</code> and a gradient <code>d = gradient(x)</code></li><li>a function <code>c = cost(x)</code> and an in-place gradient <code>gradient!(d,x)</code></li><li>a combined cost-grad function <code>(c,d) = costgrad(x)</code></li><li>a combined cost-grad function <code>(c, d) = costgrad!(d, x)</code> that computes the gradient in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/interface/problem.jl#L1-L20">source</a></section></article><h3 id="State"><a class="docs-heading-anchor" href="#State">State</a><a id="State-1"></a><a class="docs-heading-anchor-permalink" href="#State" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.State" href="#AlgorithmsInterface.State"><code>AlgorithmsInterface.State</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">State</code></pre><p>An abstract type to represent the state an iterative algorithm is in.</p><p>The state consists of any information that describes the current step the algorithm is in and keeps all information needed from one step to the next.</p><p><strong>Properties</strong></p><p>In order to interact with the stopping criteria, the state should contain the following properties, and provide corresponding <code>getproperty</code> and <code>setproperty!</code> methods.</p><ul><li><code>iteration</code> – the current iteration step <span>$k$</span> that is is currently performed or was last performed</li><li><code>stopping_criterion_state</code> – a <a href="../stopping_criterion/#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> that indicates whether an <a href="#Algorithm"><code>Algorithm</code></a> will stop after this iteration or has stopped.</li><li><code>iterate</code> the current iterate <span>$x^{(k)}$</span>.</li></ul><p><strong>Methods</strong></p><p>The following methods should be implemented for a state</p><ul><li><a href="#AlgorithmsInterface.increment!-Tuple{State}"><code>increment!</code></a>(state)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/interface/state.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.increment!-Tuple{State}" href="#AlgorithmsInterface.increment!-Tuple{State}"><code>AlgorithmsInterface.increment!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">increment!(state::State)</code></pre><p>Increment the current iteration a <a href="#State"><code>State</code></a> either is currently performing or was last performed</p><p>The default assumes that the current iteration is stored in <code>state.iteration</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/interface/state.jl#L27-L33">source</a></section></article><h3 id="Next:-Stopping-criteria"><a class="docs-heading-anchor" href="#Next:-Stopping-criteria">Next: Stopping criteria</a><a id="Next:-Stopping-criteria-1"></a><a class="docs-heading-anchor-permalink" href="#Next:-Stopping-criteria" title="Permalink"></a></h3><p>Proceed to the stopping criteria section to add robust halting logic (iteration caps, time limits, tolerance on successive iterates, and combinations) to this square‑root example.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../stopping_criterion/">Stopping criteria »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Saturday 8 November 2025 18:52">Saturday 8 November 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
