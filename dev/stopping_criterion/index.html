<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stopping criteria · AlgorithmsInterface.jl</title><meta name="title" content="Stopping criteria · AlgorithmsInterface.jl"/><meta property="og:title" content="Stopping criteria · AlgorithmsInterface.jl"/><meta property="twitter:title" content="Stopping criteria · AlgorithmsInterface.jl"/><meta name="description" content="Documentation for AlgorithmsInterface.jl."/><meta property="og:description" content="Documentation for AlgorithmsInterface.jl."/><meta property="twitter:description" content="Documentation for AlgorithmsInterface.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="AlgorithmsInterface.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">AlgorithmsInterface.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../interface/">Interface</a></li><li class="is-active"><a class="tocitem" href>Stopping criteria</a><ul class="internal"><li><a class="tocitem" href="#Why-separate-stopping-logic?"><span>Why separate stopping logic?</span></a></li><li><a class="tocitem" href="#Built-in-criteria:-Heron&#39;s-method"><span>Built-in criteria: Heron&#39;s method</span></a></li><li><a class="tocitem" href="#Implementing-a-new-criterion"><span>Implementing a new criterion</span></a></li><li><a class="tocitem" href="#Reference-API"><span>Reference API</span></a></li></ul></li><li><a class="tocitem" href="../logging/">Logging</a></li><li><a class="tocitem" href="../notation/">Notation</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Stopping criteria</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Stopping criteria</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/main/docs/src/stopping_criterion.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="sec_stopping"><a class="docs-heading-anchor" href="#sec_stopping">Stopping criteria</a><a id="sec_stopping-1"></a><a class="docs-heading-anchor-permalink" href="#sec_stopping" title="Permalink"></a></h1><p>Continuing the square‑root story from the <a href="../interface/#sec_interface">Interface</a> page, we now decide <strong>when</strong> the iteration should halt. A stopping criterion encapsulates halting logic separately from the algorithm update rule.</p><h2 id="Why-separate-stopping-logic?"><a class="docs-heading-anchor" href="#Why-separate-stopping-logic?">Why separate stopping logic?</a><a id="Why-separate-stopping-logic?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-separate-stopping-logic?" title="Permalink"></a></h2><p>Decoupling halting from stepping lets us:</p><ul><li>Reuse generic stopping (iteration caps, time limits) across algorithms.</li><li>Compose multiple conditions (stop after 1 second OR 100 iterations, etc.).</li><li>Query convergence indication vs. mere forced termination.</li><li>Store structured reasons and state (e.g. at which iteration a threshold was met).</li></ul><h2 id="Built-in-criteria:-Heron&#39;s-method"><a class="docs-heading-anchor" href="#Built-in-criteria:-Heron&#39;s-method">Built-in criteria: Heron&#39;s method</a><a id="Built-in-criteria:-Heron&#39;s-method-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-criteria:-Heron&#39;s-method" title="Permalink"></a></h2><p>The package ships several concrete <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a>s:</p><ul><li><a href="#AlgorithmsInterface.StopAfterIteration"><code>StopAfterIteration</code></a>: stop after a maximum number of iterations.</li><li><a href="#AlgorithmsInterface.StopAfter"><code>StopAfter</code></a>: stop after a wall‑clock time <code>Period</code> (e.g. <code>Second(2)</code>, <code>Minute(1)</code>).</li><li>Combinations <a href="#AlgorithmsInterface.StopWhenAll"><code>StopWhenAll</code></a> (logical AND) and <a href="#AlgorithmsInterface.StopWhenAny"><code>StopWhenAny</code></a> (logical OR) built via <code>&amp;</code> and <code>|</code> operators.</li></ul><p>Each criterion has an associated <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> storing dynamic data (iteration when met, elapsed time, etc.).</p><p>Recall our <a href="../interface/#sec_heron">example implementation</a> for Heron&#39;s method, where we we added a <code>stopping_criterion</code> to the <code>Algorithm</code>, as well as a <code>stopping_criterion_state</code> to the <code>State</code>.</p><pre><code class="language-julia hljs">using AlgorithmsInterface

struct SqrtProblem &lt;: Problem
    S::Float64                # number whose square root we seek
end

struct HeronAlgorithm &lt;: Algorithm
    stopping_criterion        # any StoppingCriterion
end

mutable struct HeronState &lt;: State
    iterate::Float64          # current iterate
    iteration::Int            # current iteration count
    stopping_criterion_state  # any StoppingCriterionState
end</code></pre><p>Here, we delve a bit deeper into the core components of what made our algorithm stop, even though we had to add very little additional functionality.</p><h3 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h3><p>The first core component to enable working with stopping criteria is to extend the initialization step to include initializing a <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> as well. This can conveniently be done through the same initialization functions we used for initializing the state:</p><ul><li><a href="../interface/#AlgorithmsInterface.initialize_state-Tuple{Problem, Algorithm}"><code>initialize_state</code></a> constructs an entirely new stopping state for the algorithm</li><li><a href="../interface/#AlgorithmsInterface.initialize_state!-Tuple{Problem, Algorithm, State}"><code>initialize_state!</code></a> (in-place) reset of an existing stopping state.</li></ul><pre><code class="language-julia hljs">function AlgorithmsInterface.initialize_state(problem::SqrtProblem, algorithm::HeronAlgorithm; kwargs...)
    x0 = rand() # random initial guess
    stopping_criterion_state = initialize_state(problem, algorithm, algorithm.stopping_criterion)
    return HeronState(x0, 0, stopping_criterion_state)
end

function AlgorithmsInterface.initialize_state!(problem::SqrtProblem, algorithm::HeronAlgorithm, state::HeronState; kwargs...)
    # reset the state for the algorithm
    state.iterate = rand()
    state.iteration = 0

    # reset the state for the stopping criterion
    state = AlgorithmsInterface.initialize_state!(
        problem, algorithm, algorithm.stopping_criterion, state.stopping_criterion_state
    )
    return state
end</code></pre><h3 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h3><p>During the iteration procedure, as set out by our design principles, we do not have to modify any of the code, and the stopping criteria do not show up:</p><pre><code class="language-julia hljs">function AlgorithmsInterface.step!(problem::SqrtProblem, algorithm::HeronAlgorithm, state::HeronState)
    S = problem.S
    x = state.iterate
    state.iterate = 0.5 * (x + S / x)
    return state
end</code></pre><p>What is really going on is that behind the scenes, the loop of the iterative solver expands to code that is equivalent to:</p><pre><code class="language-julia hljs">while !is_finished!(problem, algorithm,  state)
    increment!(state)
    step!(problem, algorithm, state)
end</code></pre><p>In other words, all of the logic is handled by the <a href="#AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>is_finished!</code></a> function. The generic stopping criteria provided by this package have default implementations for this function that work out-of-the-box. This is partially because we used conventional names for the fields in the structs. There, <code>Algorithm</code> assumes the existence of <code>stopping_criterion</code>, while <code>State</code> assumes <code>iterate</code> and <code>iteration</code> and <code>stopping_criterion_state</code> to exist.</p><h3 id="Running-the-algorithm"><a class="docs-heading-anchor" href="#Running-the-algorithm">Running the algorithm</a><a id="Running-the-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-algorithm" title="Permalink"></a></h3><p>We can again combine everything into a single function, but now make the stopping criterion accessible:</p><pre><code class="language-julia hljs">function heron_sqrt(x; stopping_criterion)
    prob = SqrtProblem(x)
    alg  = HeronAlgorithm(stopping_criterion)
    state = solve(prob, alg)  # allocates &amp; runs
    return state.iterate, state.iteration
end

heron_sqrt(2; stopping_criterion = StopAfterIteration(10))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.414213562373095, 10)</code></pre><p>With this function, we are now ready to explore different ways of telling the algorithm to stop. For example, using the basic criteria provided by this package, we can alternatively do:</p><pre><code class="language-julia hljs">using Dates
criterion = StopAfter(Millisecond(50))
heron_sqrt(2; stopping_criterion = criterion)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.414213562373095, 180198)</code></pre><p>We can tighten the condition by combining criteria. Suppose we want to stop after either 25 iterations or 50 milliseconds, whichever comes first:</p><pre><code class="language-julia hljs">criterion = StopAfterIteration(25) | StopAfter(Millisecond(50))  # logical OR
heron_sqrt(2; stopping_criterion = criterion)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.414213562373095, 25)</code></pre><p>Conversely, to demand both a minimum iteration quality condition <strong>and</strong> a cap, use <code>&amp;</code> (logical AND).</p><pre><code class="language-julia hljs">criterion = StopAfterIteration(25) &amp; StopAfter(Millisecond(50))  # logical AND
heron_sqrt(2; stopping_criterion = criterion)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.414213562373095, 133875)</code></pre><h2 id="Implementing-a-new-criterion"><a class="docs-heading-anchor" href="#Implementing-a-new-criterion">Implementing a new criterion</a><a id="Implementing-a-new-criterion-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-a-new-criterion" title="Permalink"></a></h2><p>It is of course possible that we are not satisfied by the stopping criteria that are provided by default. Suppose we want to stop when successive iterates change by less than <code>ϵ</code>, we could achieve this by implementing our own stopping criterion. In order to do so, we need to define our own structs and implement the required interface. Again, we split up the data into a <em>static</em> part, the <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a>, and a <em>dynamic</em> part, the <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a>.</p><pre><code class="language-julia hljs">struct StopWhenStable &lt;: StoppingCriterion
    tol::Float64    # when do we consider things converged
end

mutable struct StopWhenStableState &lt;: StoppingCriterionState
    previous_iterate::Float64       # previous value to compare to
    at_iteration::Int               # iteration at which stability was reached
    delta::Float64                  # difference between the values
end</code></pre><p>Note that our mutable state holds both the <code>previous_iterate</code>, which we need to compare to, as well as the iteration at which the condition was satisfied. This is not strictly necessary, but can be convenient to have a persistent indication that convergence was reached.</p><h3 id="Initialization-2"><a class="docs-heading-anchor" href="#Initialization-2">Initialization</a><a class="docs-heading-anchor-permalink" href="#Initialization-2" title="Permalink"></a></h3><p>In order to support these <em>stateful</em> criteria, again an initialization phase is needed. This could be implemented as follows:</p><pre><code class="language-julia hljs">function AlgorithmsInterface.initialize_state(::Problem, ::Algorithm, c::StopWhenStable; kwargs...)
    return StopWhenStableState(NaN, -1, NaN)
end

function AlgorithmsInterface.initialize_state!(
        ::Problem, ::Algorithm, stop_when::StopWhenStable, st::StopWhenStableState;
        kwargs...
)
    st.previous_iterate = NaN
    st.at_iteration = -1
    st.delta = NaN
    return st
end</code></pre><h3 id="Checking-for-convergence"><a class="docs-heading-anchor" href="#Checking-for-convergence">Checking for convergence</a><a id="Checking-for-convergence-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-for-convergence" title="Permalink"></a></h3><p>Then, we need to implement the logic that checks whether an algorithm has finished, which is achieved through <a href="#AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>is_finished</code></a> and <a href="#AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>is_finished!</code></a>. Here, the mutating version alters the <code>stopping_criterion_state</code>, and should therefore be called exactly once per iteration, while the non-mutating version is simply used to inspect the current status.</p><pre><code class="language-julia hljs">function AlgorithmsInterface.is_finished!(
        ::Problem, ::Algorithm, state::State, c::StopWhenStable, st::StopWhenStableState
)
	k = state.iteration
	if k == 0
		st.previous_iterate = state.iterate
		st.at_iteration = -1
		return false
	end

	st.delta = abs(state.iterate - st.previous_iterate)
	st.previous_iterate = state.iterate
	if st.delta &lt; c.tol
		st.at_iteration = k
		return true
	end
	return false
end

function AlgorithmsInterface.is_finished(
        ::Problem, ::Algorithm, state::State, c::StopWhenStable, st::StopWhenStableState
)
	k = state.iteration
	k == 0 &amp;&amp; return false

	Δ = abs(state.iterate - st.previous_iterate)
	return Δ &lt; c.tol
end</code></pre><h3 id="Reason-and-convergence-reporting"><a class="docs-heading-anchor" href="#Reason-and-convergence-reporting">Reason and convergence reporting</a><a id="Reason-and-convergence-reporting-1"></a><a class="docs-heading-anchor-permalink" href="#Reason-and-convergence-reporting" title="Permalink"></a></h3><p>Finally, we need to implement <a href="#AlgorithmsInterface.get_reason-Tuple{StoppingCriterion, StoppingCriterionState}"><code>get_reason</code></a> and <a href="#AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion, StoppingCriterionState}"><code>indicates_convergence</code></a>. These helper functions are required to interact with the <a href="../logging/#sec_logging">logging system</a>, to distinguish between states that are considered ongoing, stopped and converged, or stopped without convergence.</p><pre><code class="language-julia hljs">function AlgorithmsInterface.get_reason(c::StopWhenStable, st::StopWhenStableState)
    (st.at_iteration &gt;= 0 &amp;&amp; st.delta &lt; c.tol) || return nothing
    return &quot;The algorithm reached an approximate stable point after $(st.at_iteration) iterations; the change $(st.delta) is less than $(c.tol).&quot;
end

AlgorithmsInterface.indicates_convergence(c::StopWhenStable, st::StopWhenStableState) = true</code></pre><h3 id="Convergence-in-action"><a class="docs-heading-anchor" href="#Convergence-in-action">Convergence in action</a><a id="Convergence-in-action-1"></a><a class="docs-heading-anchor-permalink" href="#Convergence-in-action" title="Permalink"></a></h3><p>Then we are finally ready to test out our new stopping criterion.</p><pre><code class="language-julia hljs">criterion = StopWhenStable(1e-8)
heron_sqrt(16.0; stopping_criterion = criterion)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(4.0, 7)</code></pre><p>Note that our work payed off, as we can still compose this stopping criterion with other criteria as well:</p><pre><code class="language-julia hljs">criterion = StopWhenStable(1e-8) | StopAfterIteration(5)
heron_sqrt(16.0; stopping_criterion = criterion)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(4.248505646582453, 5)</code></pre><h3 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h3><p>Implementing a criterion usually means defining:</p><ol><li>A subtype of <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a>.</li><li>A state subtype of <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> capturing dynamic fields.</li><li><code>initialize_state</code> and <code>initialize_state!</code> for setup/reset.</li><li><code>is_finished!</code> (mutating) and optionally <code>is_finished</code> (non‑mutating) variants.</li><li><code>get_reason</code> (return <code>nothing</code> or a string) for user feedback.</li><li><code>indicates_convergence(::YourCriterion)</code> to mark if meeting it implies convergence.</li></ol><p>You may also implement <code>Base.summary(io, criterion, criterion_state)</code> for compact status reports.</p><h2 id="Reference-API"><a class="docs-heading-anchor" href="#Reference-API">Reference API</a><a id="Reference-API-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-API" title="Permalink"></a></h2><p>Below are the auto‑generated docs for all stopping criterion infrastructure.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.DefaultStoppingCriterionState" href="#AlgorithmsInterface.DefaultStoppingCriterionState"><code>AlgorithmsInterface.DefaultStoppingCriterionState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>DefaultStoppingCriterionState &lt;: StoppingCriterionState</p><p>A <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> that does not require any information besides storing the iteration number when it (last) indicated to stop).</p><p><strong>Field</strong></p><ul><li><code>at_iteration::Int</code> store the iteration number this state indicated to stop.<ul><li><code>0</code> means already at the start it indicated to stop</li><li>any negative number means that it did not yet indicate to stop.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L423-L434">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.GroupStoppingCriterionState" href="#AlgorithmsInterface.GroupStoppingCriterionState"><code>AlgorithmsInterface.GroupStoppingCriterionState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GroupStoppingCriterionState &lt;: StoppingCriterionState</code></pre><p>A <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> that groups multiple <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a>s internally as a tuple. This is for example used in combination with <a href="#AlgorithmsInterface.StopWhenAny"><code>StopWhenAny</code></a> and <a href="#AlgorithmsInterface.StopWhenAll"><code>StopWhenAll</code></a></p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">GroupStoppingCriterionState(c::Vector{N,StoppingCriterionState} where N)
GroupStoppingCriterionState(c::StoppingCriterionState...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L234-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.StopAfter" href="#AlgorithmsInterface.StopAfter"><code>AlgorithmsInterface.StopAfter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StopAfter &lt;: StoppingCriterion</code></pre><p>store a threshold when to stop looking at the complete runtime. It uses <code>time_ns()</code> to measure the time and you provide a <code>Period</code> as a time limit, for example <code>Minute(15)</code>.</p><p><strong>Fields</strong></p><ul><li><code>threshold</code> stores the <code>Period</code> after which to stop</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">StopAfter(t)</code></pre><p>initialize the stopping criterion to a <code>Period t</code> to stop after.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L498-L514">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.StopAfterIteration" href="#AlgorithmsInterface.StopAfterIteration"><code>AlgorithmsInterface.StopAfterIteration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StopAfterIteration &lt;: StoppingCriterion</code></pre><p>A simple stopping criterion to stop after a maximal number of iterations.</p><p><strong>Fields</strong></p><ul><li><code>max_iterations</code>  stores the maximal iteration number where to stop at</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">StopAfterIteration(maxIter)</code></pre><p>initialize the functor to indicate to stop after <code>maxIter</code> iterations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L404-L418">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.StopAfterTimePeriodState" href="#AlgorithmsInterface.StopAfterTimePeriodState"><code>AlgorithmsInterface.StopAfterTimePeriodState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StopAfterTimePeriodState &lt;: StoppingCriterionState</code></pre><p>A state for stopping criteria that are based on time measurements, for example <a href="#AlgorithmsInterface.StopAfter"><code>StopAfter</code></a>.</p><ul><li><code>start</code> stores the starting time when the algorithm is started, that is a call with <code>i=0</code>.</li><li><code>time</code> stores the elapsed time</li><li><code>at_iteration</code> indicates at which iteration (including <code>i=0</code>) the stopping criterion was fulfilled and is <code>-1</code> while it is not fulfilled.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L527-L538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.StopWhenAll" href="#AlgorithmsInterface.StopWhenAll"><code>AlgorithmsInterface.StopWhenAll</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StopWhenAll &lt;: StoppingCriterion</code></pre><p>store a tuple of <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a>s and indicate to stop, when <em>all</em> indicate to stop.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">StopWhenAll(c::NTuple{N,StoppingCriterion} where N)
StopWhenAll(c::StoppingCriterion,...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L133-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.StopWhenAny" href="#AlgorithmsInterface.StopWhenAny"><code>AlgorithmsInterface.StopWhenAny</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StopWhenAny &lt;: StoppingCriterion</code></pre><p>store an array of <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> elements and indicates to stop, when <em>any</em> single one indicates to stop. The <code>reason</code> is given by the concatenation of all reasons (assuming that all non-indicating return <code>&quot;&quot;</code>).</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">StopWhenAny(c::Vector{N,StoppingCriterion} where N)
StopWhenAny(c::StoppingCriterion...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L182-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.StoppingCriterion" href="#AlgorithmsInterface.StoppingCriterion"><code>AlgorithmsInterface.StoppingCriterion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StoppingCriterion</code></pre><p>An abstract type to represent a stopping criterion of an <a href="../interface/#Algorithm"><code>Algorithm</code></a>.</p><p>A concrete <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> should also implement a <a href="../interface/#AlgorithmsInterface.initialize_state-Tuple{Problem, Algorithm}"><code>initialize_state(problem::Problem, algorithm::Algorithm, stopping_criterion::StoppingCriterion; kwargs...)</code></a> function to create its accompanying <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a>. as well as the corresponding mutating variant to reset such a <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a>.</p><p>It should usually implement</p><ul><li><a href="#AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion, StoppingCriterionState}"><code>indicates_convergence</code></a><code>(stopping_criterion)</code></li><li><a href="#AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion, StoppingCriterionState}"><code>indicates_convergence</code></a><code>(stopping_criterion, stopping_criterion_state)</code></li><li><a href="#AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>is_finished!</code></a><code>(problem, algorithm, state, stopping_criterion, stopping_criterion_state)</code></li><li><a href="#AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>is_finished</code></a><code>(problem, algorithm, state, stopping_criterion, stopping_criterion_state)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.StoppingCriterionState" href="#AlgorithmsInterface.StoppingCriterionState"><code>AlgorithmsInterface.StoppingCriterionState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StoppingCriterionState</code></pre><p>An abstract type to represent a stopping criterion state within a <a href="../interface/#State"><code>State</code></a>. It represents the concrete state a <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> is in.</p><p>It should usually implement</p><ul><li><a href="#AlgorithmsInterface.get_reason-Tuple{StoppingCriterion, StoppingCriterionState}"><code>get_reason</code></a><code>(stopping_criterion, stopping_criterion_state)</code></li><li><a href="#AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion, StoppingCriterionState}"><code>indicates_convergence</code></a><code>(stopping_criterion, stopping_criterion_state)</code></li><li><a href="#AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>is_finished!</code></a><code>(problem, algorithm, state, stopping_criterion, stopping_criterion_state)</code></li><li><a href="#AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>is_finished</code></a><code>(problem, algorithm, state, stopping_criterion, stopping_criterion_state)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L20-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.get_reason-Tuple{StoppingCriterion, StoppingCriterionState}" href="#AlgorithmsInterface.get_reason-Tuple{StoppingCriterion, StoppingCriterionState}"><code>AlgorithmsInterface.get_reason</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_reason(stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)</code></pre><p>Provide a reason in human readable text as to why a <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> with <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> indicated to stop. If it does not indicate to stop, this should return <code>nothing</code>.</p><p>Providing the iteration at which this indicated to stop in the reason would be preferable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L36-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion, StoppingCriterionState}" href="#AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion, StoppingCriterionState}"><code>AlgorithmsInterface.indicates_convergence</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">indicates_convergence(stopping_criterion::StoppingCriterion, ::StoppingCriterionState)</code></pre><p>Return whether or not a <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> indicates convergence when it is in <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a>.</p><p>By default this checks whether the <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> has actually stopped. If so it returns whether <code>stopping_criterion</code> itself indicates convergence, otherwise it returns <code>false</code>, since the algorithm has then not yet stopped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L54-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion}" href="#AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion}"><code>AlgorithmsInterface.indicates_convergence</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">indicates_convergence(stopping_criterion::StoppingCriterion)</code></pre><p>Return whether or not a <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> indicates convergence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}" href="#AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>AlgorithmsInterface.is_finished!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_finished(problem::Problem, algorithm::Algorithm, state::State)
is_finished(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)
is_finished!(problem::Problem, algorithm::Algorithm, state::State)
is_finished!(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)</code></pre><p>Indicate whether an <a href="../interface/#Algorithm"><code>Algorithm</code></a> solving <a href="../interface/#Problem"><code>Problem</code></a> is finished having reached a certain <a href="../interface/#State"><code>State</code></a>. The variant with three arguments by default extracts the <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> and its <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> and their actual checks are performed in the implementation with five arguments.</p><p>The mutating variant does alter the <code>stopping_criterion_state</code> and and should only be called once per iteration, the other one merely inspects the current status without mutation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L111-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State}" href="#AlgorithmsInterface.is_finished!-Tuple{Problem, Algorithm, State}"><code>AlgorithmsInterface.is_finished!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_finished(problem::Problem, algorithm::Algorithm, state::State)
is_finished(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)
is_finished!(problem::Problem, algorithm::Algorithm, state::State)
is_finished!(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)</code></pre><p>Indicate whether an <a href="../interface/#Algorithm"><code>Algorithm</code></a> solving <a href="../interface/#Problem"><code>Problem</code></a> is finished having reached a certain <a href="../interface/#State"><code>State</code></a>. The variant with three arguments by default extracts the <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> and its <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> and their actual checks are performed in the implementation with five arguments.</p><p>The mutating variant does alter the <code>stopping_criterion_state</code> and and should only be called once per iteration, the other one merely inspects the current status without mutation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L100-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}" href="#AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State, StoppingCriterion, StoppingCriterionState}"><code>AlgorithmsInterface.is_finished</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_finished(problem::Problem, algorithm::Algorithm, state::State)
is_finished(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)
is_finished!(problem::Problem, algorithm::Algorithm, state::State)
is_finished!(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)</code></pre><p>Indicate whether an <a href="../interface/#Algorithm"><code>Algorithm</code></a> solving <a href="../interface/#Problem"><code>Problem</code></a> is finished having reached a certain <a href="../interface/#State"><code>State</code></a>. The variant with three arguments by default extracts the <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> and its <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> and their actual checks are performed in the implementation with five arguments.</p><p>The mutating variant does alter the <code>stopping_criterion_state</code> and and should only be called once per iteration, the other one merely inspects the current status without mutation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L97-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State}" href="#AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State}"><code>AlgorithmsInterface.is_finished</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_finished(problem::Problem, algorithm::Algorithm, state::State)
is_finished(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)
is_finished!(problem::Problem, algorithm::Algorithm, state::State)
is_finished!(problem::Problem, algorithm::Algorithm, state::State, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)</code></pre><p>Indicate whether an <a href="../interface/#Algorithm"><code>Algorithm</code></a> solving <a href="../interface/#Problem"><code>Problem</code></a> is finished having reached a certain <a href="../interface/#State"><code>State</code></a>. The variant with three arguments by default extracts the <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> and its <a href="#AlgorithmsInterface.StoppingCriterionState"><code>StoppingCriterionState</code></a> and their actual checks are performed in the implementation with five arguments.</p><p>The mutating variant does alter the <code>stopping_criterion_state</code> and and should only be called once per iteration, the other one merely inspects the current status without mutation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L86-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:&amp;-Tuple{StoppingCriterion, StoppingCriterion}" href="#Base.:&amp;-Tuple{StoppingCriterion, StoppingCriterion}"><code>Base.:&amp;</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">&amp;(s1,s2)
s1 &amp; s2</code></pre><p>Combine two <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> within an <a href="#AlgorithmsInterface.StopWhenAll"><code>StopWhenAll</code></a>. If either <code>s1</code> (or <code>s2</code>) is already an <a href="#AlgorithmsInterface.StopWhenAll"><code>StopWhenAll</code></a>, then <code>s2</code> (or <code>s1</code>) is appended to the list of <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> within <code>s1</code> (or <code>s2</code>).</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">a = StopAfterIteration(200) &amp; StopAfter(Minute(1))</code></pre><p>Is the same as</p><pre><code class="nohighlight hljs">a = StopWhenAll(StopAfterIteration(200), StopAfter(Minute(1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L162-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:|-Tuple{StoppingCriterion, StoppingCriterion}" href="#Base.:|-Tuple{StoppingCriterion, StoppingCriterion}"><code>Base.:|</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">|(s1,s2)
s1 | s2</code></pre><p>Combine two <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> within an <a href="#AlgorithmsInterface.StopWhenAny"><code>StopWhenAny</code></a>. If either <code>s1</code> (or <code>s2</code>) is already an <a href="#AlgorithmsInterface.StopWhenAny"><code>StopWhenAny</code></a>, then <code>s2</code> (or <code>s1</code>) is appended to the list of <a href="#AlgorithmsInterface.StoppingCriterion"><code>StoppingCriterion</code></a> within <code>s1</code> (or <code>s2</code>)</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">a = StopAfterIteration(200) | StopAfter(Minute(1))</code></pre><p>Is the same as</p><pre><code class="nohighlight hljs">a = StopWhenAny(StopAfterIteration(200), StopAfter(Minute(1)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L213-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.summary-Tuple{IO, StoppingCriterion, StoppingCriterionState}" href="#Base.summary-Tuple{IO, StoppingCriterion, StoppingCriterionState}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">summary(io::IO, stopping_criterion::StoppingCriterion, stopping_criterion_state::StoppingCriterionState)</code></pre><p>Provide a summary of the status of a stopping criterion – its parameters and whether it currently indicates to stop. It should not be longer than one line</p><p><strong>Example</strong></p><p>For the <a href="#AlgorithmsInterface.StopAfterIteration"><code>StopAfterIteration</code></a> criterion, the summary looks like</p><pre><code class="nohighlight hljs">Max Iterations (15): not reached</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/AlgorithmsInterface.jl/blob/c0ad8e38cc5a442caf9239973ad4eca71f19721e/src/stopping_criterion.jl#L114-L127">source</a></section></article><h3 id="Next:-Logging"><a class="docs-heading-anchor" href="#Next:-Logging">Next: Logging</a><a id="Next:-Logging-1"></a><a class="docs-heading-anchor-permalink" href="#Next:-Logging" title="Permalink"></a></h3><p>With halting logic done, proceed to the <a href="../logging/#sec_logging">logging section</a> to instrument the same example and capture intermediate diagnostics.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/">« Interface</a><a class="docs-footer-nextpage" href="../logging/">Logging »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Saturday 8 November 2025 18:52">Saturday 8 November 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
